# Computer System, A Programmer's Perspective

## Overview

以下内容为 Computer System, A Programmer's Perspective. (3th) 中文译名: 深入理解计算机系统的总结性内容. 兼带有更多的blog, wiki等的引用. 绝非原创 :)

## Catalog

- [6 存储器层次结构](#存储器层次结构)
- [8 异常控制流](#异常控制流)
- [9 虚拟内存](#虚拟内存)

### 虚拟内存

Recommend Ref:

- https://en.wikipedia.org/wiki/Memory_management_(operating_systems)
- https://en.wikipedia.org/wiki/Virtual_address_space
- https://en.wikipedia.org/wiki/Virtual_memory

虚拟内存是硬件异常, 硬件地址翻译, 主存, 磁盘文件和内核软件的完美交互, 它为每个进程提供了一个大的, 一致的和私有的地址空间.

虚拟内存提供三个很重要的能力:

1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存, 在主存中只保存活动区域, 并根据需要在磁盘和主存之间来回传送空间, 通过这种方式, 它高效地使用了主存.
2. 它为每个进程提供了一致的地址空间, 从而简化了内存管理.
3. 它保护了每个进程的地址空间不被其它进程破坏.

延伸:

本文写作时, 是先写了虚拟内存, 但深刻理解存储器层次结构对于理解"虚拟内存"概念也很关键! 这里仅提我认为关键的几点:

首先需要明白, CPU (寄存器, 三级缓存) -> 主存 -> 磁盘存储 -> 网络空间存储(网盘...🙃) 存取速度依次有量级的下降; 上级存储设备是下级存储设备的"高速缓存";

其次, "运行程序"需要先将相应代码&数据加载到主存中, 然后由CPU在"适时"存取;

再次, 程序中使用取地址操作, 如&等, 取到的内存"地址", 其实是虚拟地址空间中的地址(在当下的现代操作系统中);

到这里, 我需要强调的是"实际主存"是有限的, 从几百M的时代一直到当下8G内存几乎成为标配, 但主存一直是比较稀缺的资源. 而虚拟内存却可以很大(当下, 主流64位操作系统 8 bytes用来表示虚拟地址空间, `16384 PB` 的"虚拟内存空间", 真是相当大的地址空间, 在当前看来).

在传统存储器层次结构中, 我们知道上级存储设备是下级存储设备的"高速缓存", In virtual memory perspective(在虚拟内存的视角来看), 虚拟内在取代了主存的地位, 并将主存是被视作是存储在磁盘上的地址空间的高速缓存(与传统存储器层次结构中一致).

**物理和虚拟寻址**

主存设备实质是一个连续的可用于存储的"硬件设备", 将其抽象化为一个由M个字节大小的单元组成的数组. 每个字节都有唯一的"物理地址"(Physical Address), 第一个字节为0, 接下来字节地址为1, 依此类推!

如果CPU直接使用这样的"物理地址"来访问内存, 我们称这种方式为物理寻址. 早期的PC使用物理寻址, 而且诸如数字信息处理器, 嵌入式微控制器以及Cray超级计算机这样的系统仍然继续使用这种寻址方式.

然后现代处理器使用使用的是一个称为"虚拟寻址"的寻址方式: (此处应该有图🙃)

```
                          PM
-----------------       -----
|      VA       |  PA   |   |
| CPU ---> MMU  | --->  -----
|               |       |   |
|---------------|       -----

说明:
Virtual Address, VA
Physical Address, PA
Memory Management Unit, MMU
Primary Memory, PM
```

CPU通过一个虚拟地址(Virtual Address, VA)来访问主存;

而负责将虚拟地址"翻译"为物理地址需要CPU与操作系统共同完成, 在CPU上的部分是被称为内存管理单元(Memory Management Unit, MMU)的专用硬件, MMU使用存放在主存中的查询表来动态的翻译虚拟地址, 该表的内容由操作系统管理(页表).

**地址空间**

比较好理解, pass

**虚拟内在作为缓存的工具**

和存储器层次结构中其他缓存一样, 磁盘(较低层)上的数据被分割为块, 作为磁盘和主存(较高层)之间的传输单元. VM系统同样将虚拟内存分割为大小固定的块, 称为虚拟页(Virtual Page, VP). 类似的物理内存也被分割为"物理页"(Physical Page, PP), 其大小与虚拟页保持一致, P=2**p. 

物理页也称为页帧(page frame).

在任意时刻, 虚拟页面的集合都可以分为三个不相交的子集:

- 未分配: VM系统还未分配(或者创建)的页, 未分配的块没有任务数据和它们相关联, 因此也不占用任务磁盘空间.
- 缓存的: 当前已缓存的物理内存中的已分配页.
- 未缓存的: 未缓存在物理内存中的已分配页.

为了有助于清晰理解存储层次结构中不同的缓存概念, 我们将使用术语:

SRAM缓存: 用来表示位于CPU和主存之间的L1,L2,L3高速缓存.

DRAM缓存: 表示虚拟内存系统的缓存, 它在主存中缓存虚拟页

鉴于DRAM不命中时, 读取磁盘第一个字节(寻道)的巨大开销, 对DRAM缓存的总是使用写回, 而非直写.

延伸:

```
Ref: https://www.geeksforgeeks.org/write-through-and-write-back-in-cache/

大体上:
write through: 同时修改缓存与磁盘数据
write back: 仅修改缓存, 在缓存换出时, 根据dirty位, 决定是否更新磁盘数据
```

**页表**

页表(page table)是一个存放在内存中的数据结构, 其上记录了虚拟地址到物理地址的映射.

每次地址翻译硬件将一个虚拟地址转换为物理地址时, 都会读取页表. 操作系统负责维护页表的内容, 以及在磁盘与DRAM之间来回传送页.

通过一个标志位 0/1 & 地址字段来判断三种状态: 未分配 `0+null`; 已缓存 `1+address`; 未缓存 `0+address`.

需要注意的是, DRAM与虚拟内存之间cache mapping是全相联(associative mapping), 所以任意物理页都可以包含任意虚拟页.

延伸

```
三种cache mapping算法

Ref: https://www.geeksforgeeks.org/cache-memory-in-computer-organization/

每个进程独自拥有自己的虚拟内存空间&页表.

多级页表提升主存使用效率; 降低页表占用空间.
```

**页命中**

pass

**缺页**

CPU引用了 VP3 中的一个字, 查询页表发现 VP3 并未被缓存, 并且触发一个缺页异常(trap, 参见[异常控制流](#异常控制流)), 缺页异常调用内核中的缺页异常处理程序, 置换DRAM中的页, 加载VP3(此时VP3数据存储在磁盘中)至DRAM, 同时处理被置换出去的页面(cache write back algorithm).

此次的缺页, 是指处理虚拟内存三种状态之一的: 未缓存(已分配)的页面.

**分配页面**

pass

**局部性原理**

在虚拟内存系统中, 虽然不命中处理很大, 但由于局部性原理, 即使程序使用的内存集合大于实际物理内存, 但是局部性原则保证了在任意时刻, 程序将趋向于在一个较小的活动页面集合上工作. 所以开销主要集中在页面的初始调度上(调入内存).

**虚拟内存作为内存管理的工具**

如上提到的, 每个进程拥有自己独立的虚拟内存空间&页表; 一个DRAM可以包含多个虚拟页(全关联的缓存映射方式);

按需高度和独立的虚拟地址空间的结合, 对系统中内存的使用和管理造成了深远的影响, 特别的:

- 简化链接
- 简化加载
- 简化共享
- 简化内存分配

延伸

```
以上几项, 链接, 加载, 共享, 内存分配需要一些C编程经验等, 才能理解具体影响, 避免内容过度延伸, 冗长不再详细介绍.

强烈推荐阅读原书!
```

**虚拟内存作为内存保护的工具**

三层保护:

- 不允许应用程序修改只读的内存(代码片段, 数据等)
- 不允许它读或修改内核中的代码和数据结构.
- 不允许它读其它进程的私有内存
- 不允许它修改任何与其它进程共享的虚拟页面, 除非所有共享者都显式地允许它这么做
- 其它我未想到及书上未提及的...

上面说到, 通过页表中每一项(Page Table Entity, PTE)映射实际物理地址, 因此在PTE中加上相应许可位来控制对一个虚拟页面内容的访问变得什么自然容易, 如下图示意:

```
Process 0:        SUP  READ  WRITE  Address
           VP 0: | Y  | Y  | Y    | PP6    |
           VP 1: | N  | Y  | N    | PP6    |

Process 1:        SUP  READ  WRITE  Address
           VP 0: | Y  | Y  | Y    | PP6    |
           VP 1: | N  | Y  | N    | PP6    |
```

如果一条指含违背了这些许可条件, 那么CPU就触发一个一般保护故障, 将控制传递给一个内核中的异常处理程序. Linux Shell 一般将这种异常报告为 `segmentation fault` :)

**地址翻译**

pass

**Linux虚拟内存系统**

一个Linux进程的虚拟内存

```
|--------------------------------------------------------
| 与进程相关的数据结构(如页表, task和mm结构, 内核栈)
|--------------------------------------------------------
| 物理内存
|--------------------------------------------------------
| 内核代码和数据
|--------------------------------------------------------
|--------------------------------------------------------
| 用户栈 (向下拓展)
|--------------------------------------------------------
| space
| space
|--------------------------------------------------------
| 共享库的内存映射区域 (向上拓展)
|--------------------------------------------------------
| space
| space
|--------------------------------------------------------
| 运行时堆 (通过malloc分配的)
|--------------------------------------------------------
| 未初始化的数据(.bss)
|--------------------------------------------------------
| 已初始化的数据(.data)
|--------------------------------------------------------
| 代码(.text)
|--------------------------------------------------------
| 0x400000 以下不使用
| stack overflow 上的回答 https://stackoverflow.com/questions/39689516/why-is-address-0x400000-chosen-as-a-start-of-text-segment-in-x86-64-abi/39692117#39692117
|--------------------------------------------------------
```

后面还有很多内容, 鉴于时间与精力问题, 此处不再详述...

看完, 想明白, 能总结重要结论, 能再脱离资料准确说出来, 一个耗时可能会有量级提升的过程:) 只有深刻准确的理解, 才不会过段时间又双叒叕忘了🙃
