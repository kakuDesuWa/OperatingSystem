# 王道论坛 - 操作系统

- [计算机系统概述](#计算机系统概述)
- [进程管理](#进程管理)
- [内存管理](#内存管理)


### 计算机系统概述

**操作系统的基本概念**

- 操作系统的概念

计算机系统自下而上可大致分为4部分: 硬件, 操作系统, 应用程序和用户. 操作系统管理各种计算机硬件, 为应用程序提供基础, 并充当计算机硬件与用户之间的中介.

硬件如中央处理器, 内存, 输入/输出设备等, 提供基本的计算资源. 应用程序如字处理程序, 电子制表软件, 编译器, 网络浏览器等, 规定按何种方式使用这些资源来解决用户的计算问题. 操作系统控制和协调各用户的应用对硬件的分配与使用.

综上, 操作系统(Operating System, OS)是指控制和管理整个计算机系统的硬件与软件资源, 合理的组织, 高度计算机的工作与资源的分配, 进而为用户和其他软件提供方便接口与环境的程序集合.

- 操作系统的特征

操作系统的基本特征包括并发, 共享, 虚拟和异步. 

1. 并发(Concurrence)

并发是指两个或多个事件在同一时间间隔内发生. 操作系统的并发性是指计算机系统中同时存在多个运行的程序, 因此它具有处理和高度多个程序同时执行的能力. 在操作系统中, 引入进程的目的是使程序能并发执行.

注意同一时间间隔(并发)和同一时刻(并行)的区别. 在多道程序环境下, 一段时间内, 宏观上有多道程序在同时执行, 而在每个时刻, 单处理机环境下实际仅能有一道程序执行, 因此微观上这些程序仍是分时交替执行. 操作系统的并发性是通过分时得以实现的.

2. 共享(Sharing) 

资源共享, 是指系统中的资源可供内存中多个并发执行的进程共同使用. 共享可分为以下两种方式:

a. 互斥共享方式

系统中的资源如, 打印机, 磁带机, 虽然可供多个进程使用, 但一段时间内只允许一个进程访问资源(称为临界资源或独占资源)

b. 同时访问方式

系统中还有另一类资源, 允许在同一段时间内由多个进程"同时"访问. 这里所说的"同时"通常是宏观上的, 而在微观上, 这些进程可能是交替地对资源进行访问即"分离共享"的. 可供多个进程"同时"访问的典型资源是磁盘设备, 一些用重入码编写的文件也可被"同时"共享, 即允许若干个用户同时访问该文件.

并发与共享是操作系统两个最基本的特征, 两都之间互为存在的条件: 1. 资源共享是以程序的并发为条件的, 若系统不允许程序并发执行, 则自然不存在资源共享问题; 2. 若系统不能对资源共享实施有效的管理, 则必将影响到程序的并发执行, 甚至根本无法并发执行.

3. 虚拟(Virtual)

虚拟是指把一个物理上的实体变为若干逻辑上的对应物. 操作系统的虚拟技术可归纳为: 时分复用技术, 如处理器的分时共享; 空分复用技术, 如虚拟存储器;

4. 异步(Asynchronism)

多道程序环境允许多个程序并发执行, 但由于资源有限, 进程的执行并不是一贯到底的, 而是走走停停的, 它以不可预知的速度向前推进, 这就是进程的异步性.

异步性使得操作系统运行在一种随机的环境下, 可能导致进程产生与时间有关的错误(就像对全局变量的访问顺序不当会导致程序出错一样). 

- 操作系统的目标和功能

目标: 给多道程序提供良好的运行环境.

功能: 处理机管理(进程管理), 存储器管理, 设备管理, 文件管理. 为了方便用户使用操作系统, 还必须向用户提供接口作.

1. 处理机管理

可归结为对进程的管理, 并发是指在计算机同时运行多个进程, 因此进程何时创建, 何时撤销, 如何管理, 如何避免冲突, 合理共享就是进程管理的最主要的任务. 进程管理的主要功能包括进程控制, 进程同步, 进程通信, 死锁处理, 处理机高度等

2. 存储器管理

为给多道程序的运行提供良好的环境, 方便用户使用及提高内存的利用率. 主要包括内存分配, 地址映射, 内存保护与共享和内存扩充等功能.

3. 文件管理

操作系统中负责文件管理的部分称为文件系统. 文件管理包括文件存储空间的管理, 目录管理及文件读写管理和保护.

4. 设备管理

主要任务是完成用户的I/O请求, 方便用户使用各种设备, 并提高设备的利用率, 主要包括缓冲管理, 设备分配, 设备处理和虚拟设备等功能.

为方便用户使用计算机, 操作系统还提供了用户接口. 主要分2类:

1. 命令接口

又分联机命令接口, 交互式命令接口; 脱机命令接口, 批处理命令接口;

2. 程序接口

程序接口由一组系统调用命令组成. 如图形用户界面(GUI).

**操作系统的发展与分类**

- 手工操作阶段(此阶段无操作系统)

- 批处理阶段(操作系统开始出现)

为了解决手工操作阶段的人机矛盾及CPU和I/O设备之间速度不匹配的矛盾, 出现了批处理系统. 它按发展历程又分为单道批处理系统, 多道批处理系统(多道程序设计技术出现以后)

1. 单道批处理系统

a. 自动性

b. 顺序性

c. 单道性

2. 多道批处理系统

a. 多道

b. 宏观上并行

c. 微观上串行

- 分时操作系统

分时是指把处理器的运行时间分成很短的时间片, 按时间片轮流把处理器分配给各联机作业使用. 分时操作系统也是支持多道程序设计的系统. 主要特征如下:

1. 同时性
2. 交互性
3. 独立性
4. 及时性

- 实时操作系统

为了能在某个时间限制内完成某些紧急任务而不需要时间片排队, 诞生了实时操作系统. 分为硬实时操作系统与软实时系统, 分别应用场景有飞机的飞行自动控制系统; 飞机订票,银行管理系统.

- 网络操作系统和分布式计算机系统

网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信

分布式计算机系统是由多台计算机组成并满足下列条件的系统: 

1. 系统中任意两台计算机通过通信方式交换信息
2. 系统中的每台计算机都具有同等的地址, 即没有主机也没有从机
3. 每台计算机上的资源为所有用户共享
4. 系统中的任意台计算都可以构成一个子系统, 并且还能重构
5. 任何工作都可以分布在几台计算机上, 由它们并行工作, 协同完成.

主要特点: 分布性和并行性.

- 个人计算机操作系统

Window, Linux

- 嵌入式操作系统, 服务器操作系统, 多处理器操作系统

**操作系统的运行环境**

- 操作系统的运行机制

计算机系统中, 通常CPU执行2种不同性质的程序: 一种是操作系统内核程序; 另一种是用户自编程序(应用程序). 内核程序可以执行特殊指令. 在具体实现上, 将CPU的状态划划分为用户态和核心态(内核态). 应用程序运行在用户态, 内核程序运行在核心态.

层次式结构, 与硬件关联较紧密的模块, 如时钟管理, 中断处理, 设备驱动等处于最低层. 其次是运行频率较高的程序, 如进程管理, 存储器管理和设备管理. 这部分内容的指令操作工作在核心态.

大多数操作系统内核包括四方面的内容:

1. 时钟管理

最关键的设备

2. 中断机制

键盘或鼠标信息的输入, 进程的管理和高度, 系统功能的调用, 设备驱动, 文件访问等都依赖于中断机制. 现代操作系统是靠中断驱动的软件.

3. 原语

按层次设计的操作系统, 底层是一些可被调用的公用小程序. 它们各自完成一个规定的操作, 特点如下:

a. 处于操作系统的最低层, 是最接近硬件的部分

b. 这些程序的运行具有原子性, 其操作只能一气呵成(主要从系统安全性和便于管理考虑)

c. 这些程序的运行时间都比较短, 而且调用频繁

4. 系统控制的数据结构及处理

系统中用来登记状态信息的数据结构很多, 如作业控制块, 进程控制块(PCB), 设备控制块, 各类链表, 消息队列, 缓冲区, 空闲区登记表, 内存分配表等. 为了实现有效的管理, 系统需要一些基本的操作, 常见的操作有下三种:

a. 进程管理

进程状态管理, 进程调用和分派, 创建与撤销进程控制块等

b. 存储器管理

存储器的空间分配和回收, 内存信息保护程序, 代码对换程序等

c. 设备管理

缓冲区管理, 设备分配和回收等

- 中断和异常的概念

操作系统中引用了核心态和用户态这两种工作状态后, 就需要考虑如何切换. 操作系统工作在内核态, 用户程序工作在用户态. 系统不允许用户程序实现核心态的功能, 而它们又必须使用这些功能. 通过中断或异常实现之. 发生中断或异常时, 运行用户态的CPU会立即行内核态, 这是通过硬件实现的.

中断机制非常重要, 原因是, 操作系统的发展过程大体上就是一个想方设法不断提高资源利用率的过程, 而提高资源利用率就需要在程序并未使用某种资源时, 把它对那种资源的占有权释放, 而这一行为就需要通过中断实现.

中断(Interruption)也称外中断, 指来自CPU执行指令以外的事件的发生, 如设备发出的I/O结束中断, 时钟中断, 表示一个固定的时间片已到. 这一类中断通常是与当前程序运行无关的事件, 即它们与当前处理机运行的程序无关.

异常(Exception)也称内中断, 例外或陷入(trap), 指源自CPU执行指令内部的事件, 如程序的非法操作码, 地址越界, 算术溢出等引起的事件. 对异常的处理一般要依赖于当前程序的运行现场, 且异常不能被屏蔽, 一旦出现应立即处理.

- 系统调用

系统调用, 是指用户在程序中调用操作系统所提供的一些子功能, 系统调用可视为特殊的公共子程序. 系统中的各种共享资源都由操作系统统一掌管, 因此在用户程序中, 几是与资源有关的操作(如存储分配, 进行I/O传输及管理文件等), 都必须通过系统调用方式向操作系统提出服务请求, 并由操作系统代为完成. 系统调用按功能大致可分为如下几类:

1. 设备管理, 完成设备的请求或释放, 以及设备启动等功能.
2. 文件管理, 完成文件的读, 写, 创建及删除等功能.
3. 进程控制, 完成进程的创建, 撤销, 阻塞及唤醒等功能.
4. 进程通信, 完成进程间的消息传递或信号传递等功能.
5. 内存管理, 完成内存的分配, 回收以及获取作业占用内存区大小及始址等功能.

系统调用的处理需要由操作系统内核程序负责完成, 要运行在内核态. 用户程序执行"陷入指令", 相当于CPU的使用权主动交给操作系统内核程序(CPU状态由用户态进入内核态), 之后操作系统内核程序再对系统调用请求做出相应处. 

- 操作系统的体系结构

**大内核和微内核**

大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态, 从而为应用程序提供高性能的系统服务. 因为各管理模块之间共享信息, 能有效利用相互之间的有效特性, 所以具有无可比拟的性能优势. 规模增长, 程序复杂性增高. 

微内核结构, 将内核中最基本的功能(如进程管理等)保留在内核, 而将那些不需要在核心态执行的功能移到用户态执行, 从而降低了内核的设计复杂性.

微内核结构有效的地分离了内核与服务, 服务与服务, 使得它们之间的无病呻吟更加清晰, 维护的代价大大降低, 各部分可以独立地优化和演进, 从而保证了操作系统的可靠性. 但需要频繁地在核心态和用户态切换, 导致出现性能问题.

### 进程管理

**进程与线程**

- 进程的概念和特征

概念:

在多道程序环境下, 允许多个程序并发执行, 此时它们将推动封闭性, 并具有间断性及不可再现性的特征. 为此引入了进程的概念, 以便更好的描述和控制程序的并发执行. 实现操作系统的并发性与共享性(最基本要的2个特性).

Process Control Block, PCB是系统用来描述进程的基本情况和运行状态, 进而控制和管理进程的数据结构. 程序块, 相关数据块和PCB三部分构成了进程映像(进程实体). 所谓创建进程, 实质上是创建进程映像中的PCB; 同样, 撤销进程实质上是撤销进程的PCB.

PCB是进程存在的唯一标志.

进程有多种定义, 比较典型的如下:

1. 进程是程序的一次执行过程
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
3. 进程是具有独立功能的程序在一个数据集上运行的过程, 它是系统进行资源分配和高度的一个独立单位.

特征:

1. 动态性
2. 并发性
3. 独立性
4. 异步性
5. 结构性

- 进程的状态与转换

通常进程有以下五种状态, 前三种是进程的基本状态(运行, 就绪, 阻塞)

1. 运行态
2. 就绪态
3. 阻塞态
4. 创建态
5. 结束态

- 进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理, 它具有创建新进程, 锒铛已有进程, 实现进程状态转换等功能. 在操作系统中, 一般把进程控制用的程序段称为原语, 原语的特点是执行期间不允许中断, 它是一个不可分割的基本单位. 

1. 进程的创建

允许一个进程创建另一个进程, 些时创建者称为你进程, 被创建的进程称为子进程. 子进程可以继承父进程所拥有的资源. 当子进程被撤销时, 应将其从父进程那里获得的资源归还给父进程. 此处, 在撤销父进程时, 必须同时撤销其所有的子进程.

在操作系统中, 终端用户登录系统, 作业高度, 系统提供服务, 用户程序的应用请求等都会引起进程的创建. 操作系统创建一个新进程的过程如下:

a. 为新进程分配一个唯一的进程标识号, 并申请一个空白的PCB(PCB是有限的). 若PCB申请失败, 则创建失败.

b. 为进程分配资源, 为新进程的程序和数据及用户栈分配必要的内存空间(在PCB中体现). 注意, 若资源不足(如内存空间), 则并不是创建失败, 而是处于"等待态"或称"阻塞态", 等待的是内存这个资源. 

c. 初始化PCB, 主要包括初始化标志信息, 初始化处理机状态信息和初始化处理机控制信息, 以及设置进程的优先级等.

d. 若进程就绪队列能够接纳新进程, 则将新进程插入就绪队列, 等待被高度运行.

2. 进程的终止

引起进程终止的事件主要有: 

a. 正常结束, 表示进程的任务已经完成并准备退出运行. 

b. 异常结束, 表示进程在运行时, 发生了某种异常事件, 使程序无法继续运行, 如存储区越界, 保护错, 非法指令, 特权指令, I/O故障等. 

c. 外界干预, 是指进程应外界的请求而终止运行, 如操作员或操作系统干预, 父进程的请求和父进程终止.

3. 进程的阻塞和唤醒

正在执行的进程, 由于期待的某些事件未发生, 如请求系统资源失败, 等待某种操作的完成, 新数据尚未到达或无新工作可做等, 由系统自动执行阻塞原语(Block), 使自己由运行态变为阻塞态. 可见, 进程的阻塞是进程自身的一种主动行为, 也因此只有处于运行态的进程(获得CPU), 才可能将其转变为阻塞态.

当被阻塞的进程所期待的事件出现时, 如它所启动的I/O操作已完成或其所期待的数据已经到达, 由有关进程(如提供数据的进程)调用唤醒原语(Wakeup), 将等待该事件的进程唤醒.

4. 进程切换

对于通常的进程而言, 其创建, 撤销及要求由系统设备完成的I/O操作, 都是利用系统调用而进入内核, 再由内核中的相应处理程序予以完成的, 进程切换同样是在内核的支持下实现的. 

可以说任何进程都是在操作系统内核的支持下运行的.

进程切换是指处理机从一个进程的运行转到另一个进程上运行, 在这个过程中, 进程的运行环境产生了实质性的变化. 

- 进程的组织

1. PCB, 进程控制块

PCB组织方式: 链接式, 索引式

2. 程序段

程序段是指能被进程调度程序调度到CPU执行的程序代码块, 程序段可被多个进程共享.

3. 数据段

可以是进程对应的程序加工处理的原始数据, 也可以是程序执行时产生的中间结果或最终结果

- 进程的通信

进程通信是指进程之间的信息交换. PV操作是低级通信方式, 高级通信方式是指以较高的效率传输大量数据的通信方式. 高级通信方法主要有以下三类.

1. 共享存储

在通信的进程之间存在一块可直接访问的共享空间, 通过对这片共享空间进行写/读操作实现进程之间的信息交换, 需要使用同步互斥工具(如P操作, V操作)

2. 消息传递

在消息传递系统中, 进程间的数据交换是以格式化的消息(Message)为单位的. 若通论的进程之间不存在可直接访问的共享空间, 则必须利用操作系统提供的消息传递方法实现进程通信. 操作系统提供发送消息和接收消息2个原语进行数据交换.

又分为直接通信方式与间接通信方式.

3. 管道通信

所谓管道, 是指用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件, 又名pipe文件. 向管道(共享文件)提供输入的发送进程, 以字符流形式将大量的数据送入(写)管道; 而接收管道输出的接收进程(即读进程)则从管道中接收(读)数据. 为了协调双方的通信, 管道机制必须提供以下三方面的协调能力: 互斥, 同步和确定对方的存在.

管道为半双工通信, 实质是一个固定大小的缓冲区, read(), write() 在缓冲区空或满时被阻塞.

- 线程的概念和多线程模型

引入进程的目的是为了更好的使多道程序并发执行, 提高资源利用率和系统吞吐量, 增加并发程度; 而引入线程的目的则是为了减小程序在并发执行时所付出的时空开销, 提高操作系统的并发性能.

1. 线程的基本概念

线程最直接的理解就是"轻量级的进程", 它是一个基本的CPU执行单元, 也是程序执行流的最小单元, 由线程ID, 程序计数器, 寄存器集合的堆栈组成. 线程是进程中的一个实体, 是被系统产独立调度和分派的基本单位, 线程自己不拥有系统资源, 只拥有一点在运行中必不可少的资源, 但它可与同属一个进程的其他线程共享进程所拥有的全部资源. 一个线程可以创建和撤销另一个线程, 同一个进程中的多个线程之间可以并发执行. 由于线程之间的相互制约, 致使线程在运行中呈现出间断性. 结线程也有就绪, 阻塞, 运行三种基本状态.

进程只作为除CPU外的系统资源的分配单元, 线程则作为处理机的分配单元. 由于一个进程内部有多个线程, 若线程的切换发生在同一个进程内部, 则只需很少的时空开销.

2. 线程与进程的比较

a. 调度, 在传统的操作系统中, 拥有资源和独立调度的基本单位都是进程. 在引入线程的操作系统中, 线程是独立调度的基本单位, 进程是拥有资源的基本单位. 在同一进程中, 线程的切换不会引起进程切换. 在不同的进程中进行统一线程切换, 会引起进程切换.

b. 拥有资源, 不论是传统操作系统还是设有线程的操作系统, 进程都是拥有资源的基本单位, 而线程不拥有系统资源(也有一点必不可少的资源), 但线程可以访问其隶属进程的系统资源. 

c. 并发性, 在引入线程的操作系统中, 不仅进程之间可以并发执行, 而且多个线程之间也可以并发执行, 从而使操作系统具有更好的并发性, 提高了系统的吞吐量.

d. 系统开销, 由于创建或撤销进程时, 系统都要为之分配或回收资源, 如内存空间, I/O设备等. 

e. 地址空间和其他资源(如打开的文件). 进程的地址空间之间互相独立, 同一个进程的各线程间共享进程的资源, 某进程内的线程对于其他进程不可见.

f. 通信方面. 进程间通信(IPC)需要进程同步和互斥手段的辅助, 以保证数据一一致性

3. 线程的属性

多线程操作系统把线程作为独立运行(或调度)的基本单位, 此时的进程已经不再是一个基本的可执行实体, 但它仍具有与执行相关的状态. 所谓进程处于"执行"状态, 实际上是指该进程中的某线程正在执行. 线程的主要属性有:

a. 线程是轻型实体, 它不拥有系统资源, 但每个线程都就有一个唯一的标识符和一个线程控制块, 线程王控制块记录了线程执行的寄存器和栈等现场状态.

b. 不同的线程可以执行相同的程序, 即同一个服务程序被不同的用户调用时, 操作系统把它们创建成不同的线程.

c. 同一个进程中的各个线程共享该进程所拥有的资源.

d. 线程是处理机的独立调度单位, 多个线程是可以并发执行的. 在单CPU的计算机中, 各线程可交替地占用CPU; 在多CPU的计算机系统中, 各线程可同时占用不同的CPU. 若各个CPU同时为一个进程内的各线程服务, 则可缩短进程的处理时间.

e. 一个线程被创建后, 便开始了它的生命周期, 直至终止.

4. 线程的实现方式

线程的实现可以分为两类: 用户级线程(User-Level Thread, ULT)和内核级线程(Kernel-Level Thread, KLT)

在用户级线程中, 有关线程管理的所有工作都由应用程序完成, 内核意识不到线程的存在. 应用程序可以通过使用线程库设计成多线程程序. 通常, 应用程序从单线程开始, 在该线程中开始运行, 在其运行的任何时刻, 可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程.

在内核级线程中, 线程管理的所有工作由内核完成, 应用程序没有进程线程管理的代码, 只有一个到内核级线程的编程接口. 内核为进程及其内部的每个线程维护上下文信息, 调度也在内核基于线程架构的基础上完成. 

也有些混合方式的多线程实现.

5. 多线程模型

有些系统同时支持用户线程和内核线程, 由此产生了不同的多线程模型, 即实现用户线线程和内核级线程的连接方式.

a. 多对一模型, 将多个用户级线程映射到一个内核级线程, 线程管理在用户空间完成, 此模式上, 用户级线程对操作系统不可见.

优点: 线程管理是在用户空间进行的, 因而效率比较高.

缺点: 一个线程在使用内核服务时被阻塞, 整个进程都被阻塞; 多个线程不能并行地在多处理机上.

b. 一对一模型, 将每个用户级线程映射到一个内核级线程. 

优点: 当一个线程被阻塞后, 允许另一个线程继续执行, 所以并发能力较强.

缺点: 每创建一个用户级线程都需要创建一个内核级线程与其对应, 这样创建线程的开销比较大, 会影响到应用程序的性能.

c. 多对多模型

集上两者之所长.

**处理机调度**

- 调度的概念

1. 调度的基本概念

在多道程序系统中, 进程的数量往往多于处理机的个数, 因此进程急用处理机的情况在所难免. 处理机高度是对处理机进行分配, 即从就绪队列中按照一定的算法(公平, 高效)选择一个进程, 并将处理机分配给它运行, 以实现进程并发地执行. 

处理机调度是多道程序操作系统的基础, 是操作系统设计的核心问题.

2. 调度的层次

a. 作业调度, 又称高级调度, 其主要任务是按一定的原则从外在上处于后备状态的作业中挑选一个(或多个)作业, 给它(们)分配内在, 输入/输出设备等必要的资源, 并建立相应的进程, 以使它(们)获得竞争处理机的权利.

b. 中级调度, 又称内存调度, 其作用是提高内存利用率和系统吞吐量. 为些, 应将那些暂时不能运行的进程调至外存等待, 把此时的进程状态称为挂想态. 当它们已具备运行条件且内存又稍有空闲时, 由嘴调度来决定把外存上的那些具备运行条件的就绪进程, 再重新调入内存, 并修改其状态为就绪态, 挂在就绪队列上等待.

c. 进程调度, 又称低级调度, 其主要任务是按照某种方法和 策略从就绪队列中选取一个进程, 将处理机分配给它. 进程调度是操作系统中最基本的一种调度, 在一般的操作系统中都必须配置进程调度. 进程调度频率很高, 一般几十毫秒一次.

3. 三级调度的联系

作业调度从外存的后备的后备队列中选择一批作业进入内存, 为它们建立进程, 这些进程被卷入就绪队列, 进程调度从就绪队列中选出一个进程, 并把其状态改为运行态, 把CPU分配给它. 中级调度是为了提高内存的利用率, 系统将那些暂时不能运行的进程挂起来. 当内存空间宽松时, 通过中级调度选择具备运行条件的进程, 将其唤醒.

- 调度的时机, 切换与过程

进程调度和切换程序是操作系统内核程序. 

不能进行进程的高度与切换的情况有以下几种:

1. 在处理中断的过程中

2. 进程在操作系统内核程序临界区中

3. 其他需要完全屏蔽中断的原子操作过程中

- 进程调度方式

所谓进程调度方式, 是指当某个进程正在处理机上执行时, 若有某个更为重要或紧迫的进程需要处理, 即有优先权更高的进程进入就绪队列

分非剥夺调度与剥夺调度

- 调度的基本准则

评价不同处理机调度算法的性能, 有下几个维度:

1. CPU利用率
2. 系统吞吐量, 不同作业耗时不同
3. 周转时间, 是指从作业提交到作业完成所经历的时间, 是作业等待, 在就绪队列中排队, 在处理机上运行及进行输入/输出操作所花费时间的总和.
4. 等待时间, 指进程处于等处理机状态的时间之和, 衡量一个算法的好坏的生般考查量.
5. 响应时间, 响应时间指从用户提交请求到系统首次产生响应所用的时间. 在交互系统中, 一般采用响应时间作为衡量调度算法的重要准则之一.

- 典型的调度算法

1. 先来先服务(FCFS)调度算法

FCFS调度算法是一种最简单的调度算法, 它既可用于作业调度, 又可用于进程调度. 

在作业调度中, 算法每次从后备作业队列中选择最先进入该队列的一个或几个作业, 将它们调入内存, 分配必要的资源, 创建进程并放入就绪队列.

在进程调度中, FCFS调度算法每次从就绪队列中选择最先进入该队列的进程, 将处理机分配给它, 使之投入运行, 直到完成或因某种原因而阻塞时才释放处理机.

FCFS算法属于不可剥夺算法, 不能作为分时系统和实时系统的主要调度算法, 但常被结合其他调度调度策略中使用.

FCFS特点: 简单, 但效率低; 对长作业比较有利, 但对短作业不利(相对SJF和高响应比算法); 有利于CPU繁忙型作业, 不利于I/O繁忙型作业.

2. 短作业优先(SJF)调度算法

短作业(进程)优先调度算法是指对短作业(进程)优先调度的算法. 短作业优先(SJF)调度算法从后备队列中选择一个或若干估计运行时间最短的作业, 将它调入内存运行; 短进程优先调度算法(SPF)类似.

SJF调度算法也存在不容忽视的缺点:

a. 对长作业不利

b. 该算法完全未考虑作业的紧迫程度

c. 由于作业的长短只是根据用户所提供的估计执行时间而定, 并不能真正做到短作业优先

SJF是平均等待时间, 平均周转时间最少

3. 优先级调度算法

根据新的更高优先级进程能否抢占正在执行的进程, 该算法又可分为2种:

a. 非剥夺式优先级调度算法

b. 剥夺式优先级调度算法

而根据进程创建后其优先级是否可以改变, 可将进程优先级分为2种:

a. 静态优先级

b. 动态优先级

一般, 进程优先级的设置可以参照以下原则:

a. 系统进程 > 用户进程

b. 交互型进程 > 非交互型进程

c. I/O进程 > 计算型进程

4. 高响应比优先调度算法

高响应比优先调度算法主要用于作业高度, 是对FCFS调度算法和SJF调度算法的一种综合平衡, 同时考虑了每个作业的等待时间和估计的运行时间. 在每次进行作业调度时, 先计算后备作业队列中每个作业和响应比, 从中选出响应比最高的作业调入运行.

响应比 = (等待时间 + 要求服务时间) / 要求服务时间

5. 时间片轮转调度算法

时间片轮转调度算法主要适用于分时系统. 在该算法中, 系统将所有就绪进程按到达时间的先后次序排成一个队列, 进程调度程序总是选择就绪队列中的第一个进程执行, 即先来先有务的原则, 但仅能运行一个时间片, 如100ms. 时间片的大小对系统性能影响很大, 若时间片很大, 退化为FCFS算法. 若很小, 处理机频繁切换进程开销增大.

时间片大小的影响因素: 系统的响应时间, 就绪队列中的进程数目和系统的处理能力.

6. 多级反馈队列调度算法(融合了前几种算法的优点)

多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展. 

设置多个就绪队列, 每个队列赋予不同的优先级;

不同优先级队列的时间片不同;

新进程先进入第1级队列的末尾, 按FCFS原则排队等待调度, 若未完成, 放入第2级队列;

仅当第1级队列为空, 调度程序才调度第2级队列中的进程, 若处理机正在执行第i级队列中的某进程, 此时又有新进程进入优先级高的队列, 则此时新进程将抢占正在进行进程的处理;

**进程同步**

- 进程同步的基本概念

在多道程序环境下, 进程是并发执行的, 不同进程之间存在着不同的相互制约关系. 进程同步即为协调进程之间的相互制约关系.

1. 临界资源

一次仅允许一个进程使用的资源, 如打印机, 一些变量, 数据. 对临界资源的访问, 必须互斥的进行, 在每个进程中, 访问临界资源的那段代码可称为临界区. 临界资源访问的4部分:

a. 进入区, 进入临界区, 进入区要检查可否进入, 设置正在访问临界共的标志, 以阻止其他进程同时进入临界区

b. 临界区, 进程中访问临界资源的那段代码

c. 退出区, 将正在访问临界区的标志清除

d. 剩余区, 代码中的其余部分.

2. 同步

同步亦称直接制约关系, 进程间的直接制约关系源于它们之间的相互合作.

如输入进程A通过单缓冲向进程B提供数据, 当该缓冲区空时, 进程B不能获得所需数据而阻塞, 一旦进程A将数据送入缓冲区, 进程B就被唤醒. 反之, 当缓冲区满时, 进程A被阻塞, 仅当进程B取走缓冲数据时, 才唤醒进程A.

3. 互斥

互斥也称间接制约关系, 如打印机资源, A进程使用打印机, 必须等B进程释放打印机资源.

- 实现临界区互斥的基本方法

1. 软件实现方法

在进入区设置并检查一些标志来标明是否有进程在临界区中, 若已有进程在临界区, 则在进入区通过循环检查进行等待, 进程离开临界区后则在退出区修改标志.

算法1: 单标志法(违背空闲让进), 设置turn

算法2: 双标志法先检查(违背忙则等待), 设置flag

算法3: 双标志法后检查(饥饿现象), 设置flag

算法4: Peterson's Algorithm. 设置turn与flag

2. 硬件实现方法

a. 中断屏蔽方法

当一个进程正在使用处理机执行它的临界区代码时, 防止其他进程进入临界区进行访问的最简方法是, 禁止一切中断发生, 称之为屏蔽中断, 关中断.(CPU只在发生中断时切换进程)

这种方法限制了处理机交替执行程序的能力, 因此执行效率会明显降低. 

b. 硬件指令方法

TestAndSet指令: 这条指令是原子操作, 即执行代码时不允许被中断. 其功能是读出指定标志后把该标志设置为真. 

Swap指令: 该指令的功能是交换两个字(字节)的内容.

- 信号量

信号量机制是一种功能较强的机制, 可用来解决互斥与同步问题, 它只能被两个标准的原语wait(S)和signal(S)访问, 也可记为"P"操作和"V"操作.

原语是指完成某种功能且不被分割, 不被中断执行的操作序列, 通常可由硬件来实现. 例如前面的TestAndSet, Swap. (原语功能在单处理机上可由软件通过屏蔽中断实现)

1. 整型信号量

整形信号量被定义为一个用于表示资源数目的整形量S, wait和signal操作可描述为

```
wait(S) {
    while(S<=0);
    S = S - 1;
}

signal(S) {
    S = S + 1;
}
```

wait操作中, 只要信号量S<=0就会不断测试. 该机制并未遵循"让权等待", 而是使进程处于"忙等"的状态.

2. 记录型信号量

记录型信号量是不存在"忙等"现象的进程同步机制. 除需要一个用于代表资源数目的整形变量value外, 再增加一个进程链表L, 用于链接所有等待该资源的进程. 记录型信号量得名于采用记录型的数据结构. 记录型信号量可描述为:

```
typedef struct{
    int value;
    struct process *L;
} semaphore
```

相应的wait(S)和signal(S)操作如下:

```
void wait(semaphore S) {
    S.value--;
    if(S.value) {
        // add this process to S.L;
        block(S.L);
    }
}
```

wait操作, S.value-- 表示进程请求一个该类资源, 当S.value<0时, 表示该资源已分配完毕, 因此进程应调用block原语, 进行自我阻塞, 放弃处理机, 并插入该类资源的等待队列S.L, 可见该机制遵循了"让权等待"的准则.

```
// 相当于释放资源
void signal(semaphonre S) {
    S.value++;
    if(S.value<=0) {
        // remove a process from S.L
        wakeup(P);
    }
}
```

signal操作, 表示进程释放一个资源, 使系统中可供分配的该类资源数增1, 帮有S.value++.若加1后仍是S.value<=0, 则表示在S.L中仍有等待该资源的进程被阻塞, 故还应调用wakeup原语, 将S.L中的第一个等待进程唤醒.

3. 利用信号量实现同步

信号量机制能用于解决进程间的各种同步问题. 设S为实现进程P1, P2同步的公共信号量, 初值为0. 进程P2中的语句y要使用进程P1中语句x的运行结果, 所以只有当语句x执行完成之后语句y才可以执行. 其实现进程同步的算法如下示意:

```
semaphore S=0;

P1(){
    ...     // do some thing
    x;      // 语句x    
    V(S);   // 告诉进程P2, 语句x已经完成
    ...     // do some thing
}

P2(){
    ...     // do some thing
    P(S);   // 检查语句x是否已经运行完成
    y;      //检查无误, 运行y语句
    ...     // do some thing
}
```

4. 利用信号量实现进程互斥

信号量机制也能很方便解决进程互斥问题, 设S为实现进程P1, P2互斥的信号量,由于每次只允许一个进程进入临界区, 所以S的初值应为1(即可用资源数为1). 只需把临界区置于P(S)和V(S)之间, 即可实现两个进程对临界资源的互斥访问, 其算法如下示意:

```
semaphore S=1;

P1(){
    ...
    P(S);           // 准备开始访问临界资源, 加锁
    进程P1的临界区;
    V(S);           // 访问结束, 解锁
    ...
}

P2(){
    ...
    P(S);           // 准备开始访问临界资源, 加锁
    进程P2的临界区;
    V(S);           // 访问结束, 解锁
    ...
}
```

互斥是不同进程对同一信号量进行P, V操作实现的, 一个进程成功对信号量执行了P操作后进入临界区, 并在退出临界区后, 由该进程对该信号量执行V操作, 表示当前没有进程进入临界区, 可以让其它进程进入.

5. 利用信号量实现前驱关系

6. 分析进程同步和互斥问题的方法步骤

a. 关系分析

b. 整理思路

c. 设置信号量

- 管程

1. 管程的定义

系统中各种硬件资源和软件资源, 均可用数据结构抽象的描述其资源我, 即用少量信息和对资源所执行的操作来表征该淘汰, 而忽略它们的内部结构和实现细节. 

管程是由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块, 这组操作能初始化并改变管程中的数据和同步进程.

2. 管程的组成

a. 局部于管程的共享结构数据说明

b. 对该数据结构的进行操作的一组过程

c. 对局部于管程的共享数据设置初始值语句

3. 管程的基本特性

a. 局部于管程的数据只能被局部于管程内的过程所访问

b. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据

c. 每次仅允许一个进程在管程内执行某个内部过程

- 经典同步问题

1. 生产者 - 消费者问题

问题描述:

一组生产者进程和一组消费者进程共享一个初始为空, 大小为n的缓冲区, 只有缓冲区没满时, 生产者才能把消息放入缓冲区, 否则必须等待; 只有缓冲区不为空时, 消费者才能从中取出消息, 否则必须等待. 由于缓冲区是临界资源, 它只允许一个生产者放入消息, 或一个消费者从中取出消息.

```
semaphore   mutex = 1;
semaphore   empty = 1;
semaphore   full  = 1;

producer() {
    while(1) {
        produce an item in nextp;
        P(empty);                   // 需要什么P一下...请求资源
        P(mutex);                   // 用来控制互斥访问临界区
        add nextp to buffer;        // buffer为临界区, 互斥访问
        V(mutex);                   // 用来控制互斥访问临界区
        V(full);                    // 提供什么V一下...释放资源
    }
}

consumer() {
    while(1) {
        P(full);
        P(mutex);
        remove an item from buffer;
        V(mutex);
        V(empty);
    }
}
```

拓展问题:

桌子上有一个盘子, 每次只能向其中放入一个水果. 爸爸专向盘子中放苹果, 妈妈专向盘子中放橘子, 儿子专等吃盘子中的橘子, 女儿专等吃盘子中的苹果. 只有盘子为空时, 爸爸或妈妈才可向盘子中放一个水果; 仅当盘子中有自己需要的水果时, 儿子或女儿可以从盘子中取出.

```
semaphore plate = 1, apple = 0, orange = 0;

dad() {
    prepare an apple;
    P(plate);
    put the apple on the plate;
    V(plate);
}

mom() {
    prepare an orange;
    P(plate);
    put the orange on the plate;
    V(plate);
}

son() {
    while(1) {
        P(orange);
        take an orange from the plate;
        V(plate);
        eat the orange;
    }
}

daughter() {
    while(1) {
        P(apple);
        take an apple from the plate;
        V(plate);
        eat the apple;
    }
}
```

2. 读者-写者问题

问题描述:

有读者和写者两组并发进程, 共享一个文件, 当两个或以上的读进程同时访问共享数据时不会产生副作用, 但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误. 因此要求: 1. 允许多个读者可以同时对文件执行操作; 2. 只允许一个写者往文件中写信息; 3. 任一写者在完成写操作前不允许其他读者或写者工作; 4. 写者执行写操作前, 应让已有的读者和写者全部退出.

```
// 读进程优先

int count = 0;           // 用于记录当前的读者数量
semaphore mutex = 1;     // 用于保护更新count变量时的互斥
semaphore rw = 1;        // 用于保证读者和写者互斥地访问文件

writer() {
    while(1) {
        P(rw);          // 互斥访问共享文件
        writing;        // 写入
        V(rw);          // 释放共享文件
    }
}

reader() {
    while(1) {
        P(mutex);       // 互斥访问count变量
        if(count==0)    // 当第一个读进程读共享文件时, 阻止写进程写
            P(rw);
        count++;
        V(mutext)       // 释放互斥变量count
        reading;        // 读取
        P(mutex);       // 互斥访问count变量
        count--;
        if(count==0)    // 当最后一个读进程读完共享文件, 允许写进程写
            V(rw);
        V(mutex);
    }
}
```

```
// "写进程优先" or 读写公平

int count=0;
semaphore mutex=1;
semaphore rw=1;
semaphore w=1;

writer() {
    while(1) {
        P(w);
        P(rw);
        writing;
        V(rw);
        V(w);
    }
}

reader() {
    while(1) {
        P(w);
        P(mutex);
        if(count==0)
            P(rw);
        count++;
        V(mutex);
        V(w);
        reading;
        P(mutex)
        count--;
        if(count==0)
            V(rw)
        V(mutex);
    }
}
```

第二种方法的重点在于竞争`semaphore w`

3. 哲学家进餐问题

问题描述:

 一张圆桌边上坐着5名哲学家, 每两名哲学家之间的桌上摆一根筷子, 两根筷子中间是一碗米饭. 哲学家们倾注比重精力用于思考和进餐, 哲学家在思考时, 并不影响他人. 只有当哲学家饥饿时, 才试图拿起左, 右两根筷子(一根一根的拿起). 若筷子已经在他人手上, 则需要等待. 饥饿的哲学家只有同时拿到了两根筷子才可以进餐, 进餐完毕后, 放下筷子继续思考.

```
// 当一名哲学家左右两边筷子都可用时, 才允许他抓起筷子

semaphore chopstick[5]={1, 1, 1, 1, 1};     // 初始化信号量
semaphore mutex=1;                          // 设置取筷子的信号量

Pi() {
    do{
        P(mutex);               // 在取筷子前获得互斥量
        P(chostick[i]);         // 取左筷子
        P(chostick[(i+1)%5])    // 取右筷子
        V(mutex);               // 释放取筷子的信号量
        eat;
        V(chostick[i]);         // 放回左筷子
        V(chostick[(i+1)%5])    // 放回右筷子
        think;
    } while(1);
}
```

还可采用AND型信号量机制来解决哲学家进餐问题.

4. 吸烟者问题

假设一个系统有三个抽烟者进程和一个供应者进程. 每个抽烟者不停的卷烟并抽掉它, 但要卷起并抽掉一支烟, 抽烟者需要有三种材料 : 烟草, 纸和胶水. 三个抽烟者中, 第一个拥有烟草, 第二个拥有纸, 第三个拥有胶水. 供应者进程无限地提供三种材料, 供应者每次将2种材料放到桌子上, 拥有剩下一种材料的抽烟者卷一根烟并抽掉它, 并给供应者一个信号告诉已完成, 此时供应者就会将另外两种材料放到桌子上, 如此重复(让三个抽烟者轮流抽烟)

**死锁**

- 死锁的概念

1. 死锁的定义

在多道程序系统中, 由于多个进程的并发执行,改善了系统资源的利用率并提高了系统的处理能力, 但多个进程的并发执行也带来了死锁问题. 死锁是指多个进程因竞争资源而造成的一种僵局(互相等待), 若无外力作用, 这些进程都将无法向前推进.

2. 死锁产生的原因

a. 系统资源的竞争, 通常系统中拥有的不可剥夺资源, 其数量不足以满足多个进程运行的需要, 使得进程在运行过程中, 会因争夺资源而陷入僵局. 只有对不可剥夺的资源的竞争才可能产生死锁, 对可剥夺的资源的竞争是不会引起死锁的.

b. 进程推进顺序非法, 进程在运行过程中, 请求和释放资源的顺序不当, 也同样会导致死锁. 例如, 并发进程P1, P2分别保持了资源R1, R2, 而进程P1申请资源R2, 进程P2申请资源R1时, 两者都会因为所需资源被占用而阻塞. 信号量使用不当也会造成死锁. (等待对方的资源导致死锁)

c. 死锁产生的必要条件: 互斥条件, 不剥夺条件, 请求并保持条件, 循环等待条件(同类资源大于1)

- 死锁的处理策略

1. 死锁预防

设置某些限制条件, 破坏产生死锁的4个必要条件中的一个或几个

2. 避免死锁

在资源的动态分配过程中, 用某种上方法防止系统进入不安全状态

3. 死锁的检测及解除

- 死锁预防

1. 破坏互斥条件
2. 破坏不可剥夺条件
3. 破坏请求并保持条件
4. 破坏循环等待条件

- 死锁避免

同样属于事先预防策略, 施加的限制条件较弱, 可以获得较好的系统性能

1. 系统安全状态

是指系统能按某种进程推进顺序为每个进程Pi分配其所需的资源, 直到满足每个进程对资源的最大需求, 使每个进程都可顺序完成.

2. 银行家算法

著名的死锁避免算法

描述:

当进程首次申请资源时, 要测试该进程对资源的最大需求量, 若系统现存的资源可以满足它的最大需求量, 则按当前的申请量分配资源, 否则就推迟分配. 当进程在执行中继续申请资源时, 先测试该进程已申请的资源数与本次申请的资源数之和是否超过该进程对资源的最大需求量. 若超过则拒绝分配资源, 若未超过则再测试系统现存的资源能否满足该进程尚需的最大资源量, 若能满足则按当前的申请量分配, 否则也要推迟分配. 

重点:

1. 最大需求量测试(初次与再申请)
2. 现存是否能满足最大仍需量?
3. 尝试分配 + 安全性算法(可使进程按一定顺序执行后, 所有需求量都能被满足, 系统处于安全状态)
4. 分配

- 死锁检测和解除

死锁预防与死锁避免都是在为进程分配资源时施加限制条件或进行检测, 若系统为进程分配资源时不采取任何措施, 则应该提供死锁检测和解除的手段.

1. 资源分配图

2. 死锁定理

检测系统状态S是否为死锁状态.

a. 在资源分配图中, 找到既不阻塞又不孤点的进程Pi, 消去它所有的请求边和分配边(该进程可顺利执行至完)

b. Pi释放的资源可唤醒其它阻塞的进程, 继续消去其请求边与分配边, 直至消去所有的边

3. 死锁解除

a. 资源剥夺法

b. 撤销进程法

c. 进程回退法(自愿释放资源而非剥夺)

### 内存管理

**内存管理概念**

- 内存管理的基本原理和要求

操作系统对内存的划分和动态分配, 就是内存管理的概念.

内存管理的功能有:

a. 内存管理空间的分配与回收

由操作系统完成主存储器空间的分配和管理, 使程序员摆脱存储分配的麻烦, 提高编程效率

b. 地址转换

在多道程序环境下, 程序中的逻辑地址与内存中的物理地址不可能一致, 因此存储管理必须提供地址变换功能, 把逻辑地址转换成相应的物理地址.

c. 内存空间的扩充

利用虚拟存储技术或自动覆盖技术, 从逻辑上扩充内存

d. 存储保护

保证各道程序在各自的存储空间内运行, 互不干扰.

在进行具体的内存管理之前, 需要了解进程运行的基本原理和要求.

1. 程序装入和链接

创建进行首先要将程序和数据装入内存. 将用户源程序变为可在内存中执行的程序, 通常需要几下以个步骤:

a. 编译, 由编译程序将用户源代码编译成若干目标模块. 

b. 链接, 由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起, 形成一个完整的装入模块

c. 装入, 由装入程序将装入模块装入内存运行.

程序的链接有以下三种方式:

a. 静态链接, 在程序运行之前, 先将各目标模块及它们所需的库函数链接成一个完整的可执行程序, 以后不再拆开.

b. 装入时动态链接, 将用户源程序编译后所得到的一组目标模块, 在装入内存时, 采用边装入边链接的方式.

c. 运行时动态链接, 对某些目标模块的链接, 是在程序执行中需要该目标模块时才运行的, 其优点是便于修改和更新, 便于实现对目标模块的共享.

内存的装入模块在装入内存时, 同样有以下三种方式:

a. 绝对装入, 单道程序环境

b. 可重定位装入(静态重定位), 一个作业装入内存时, 必须给它分配要求的全部内存空间, 若没有足够的内存, 则不能装入该作业.

c. 动态运行时装入(动态重位), 可以将程序分配到不连续的存储区中, 可动态申请分配内在.

2. 逻辑地址空间与物理地址空间

编译后, 每个目标模块都是从0号单元开始编址, 这称为目标模块的相对地址(或逻辑地址). 当链接程序将各个模块链接成一个完整的可执行目标程序时, 链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间.

物理地址空间是指内存中物理单元的集合, 它是地址转换的最终地址, 进程在运行时执行指令和访问数据, 最后都要通过物理地址从主存中存取. 当装入程序将可执行代码装入内存时, 必须通过地址转换将逻辑地址转换成物理地址, 这个过程称为地址重定位.

3. 内存保护

重定位寄存器与界地址寄存器;  上,下寄存器

内存分配前, 需要保护操作系统不受用户进程的影响, 同时保护用户进程不受其他进程的影响. 

- 覆盖与交换

覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法.

覆盖:

基本思想, 由于程序运行时并非任何时候都要访问程序及数据的各个部分, 因此可以把用户空间分成一个固定区和一个覆盖区. 

特点, 打破了必须将一个进程的全部信息装入主存后才能运行的限制. 对主存无法存放用户程序的, 使用虚拟内存技术解决

交换:

基本思想, 把处于等待状态(或在CPU调度原则下被剥夺运行权利)的程序从内在移到辅存, 把内存空间腾出来, 这一过程又称为掏出; 把准备好竞争CPU运行的程序从辅存移到内存, 这一过程又称为换入. 

- 连续分配管理方式

1. 单一连续分配

优点: 简单, 无外部碎片. 可以采用覆盖技术, 无需额外技术支持. 缺点: 只能用于单用户, 单任务操作系统中, 有内部碎片, 存储器利用率极低.

2. 固定分配区分配

又分分区大小相等和分区大小不等2种. 前者适用于利用一台计算机去控制多个相同对象的场合, 缺乏灵活性. 后者划分为多个较小的分区, 适量的中等分区和少量大分区.

优点: 可用于多道程序设计的最简单的存储分配, 无外部碎片. 缺点: 不能实现多进程共享主存区, 存储空间利用率低.

3. 动态分区分配

又称可变分区分配, 是一种动态划分内在的分区方法.

优点: 内存利用率高. 缺点: 外部碎片(指在所有分区外的存储空间会越来越多的碎片, 这与固定分区中的内部碎片正好相对)

外部碎片可以通过紧凑技术来解决, 即操作系统不时地对进程进行移动和整理. 但这需要动态重定位寄存器的支持, 且相对费时.(该过程类似于windows系统中的磁盘整理程序, 只不过后者是对外存空间的紧凑)

动态分区的分配策略算法:

a. 首次适应算法, 空闲分区以地址递增的次序链接. 分配内存时顺序查找, 找到大小能满足要求的第一个空闲分区.

b. 最佳适应算法, 空闲分区按容量递增的方式形成分区链, 找到第一个能满足要求的空闲分区.

c. 最坏适应算法, 又称最大适应算法, 空闲分区以容量递减的次序链接, 找到第一个能满足要求的空闲分区, 即挑选出最大的分区.

d. 邻近适用算法, 又称循环首次适应算法, 由首次适应算法演变而成. 不同之处是, 分配内存时从上次查找结束的位置开始继续查找.

- 非连续分配的管理方式

非连续分配允许一个程序分散的装入不相邻的内存分区. 在连续分配管理方式中, 即使空闲内存总数超过1G, 但若无连续1G空间, 仍无法进行需要1G空间的作业. 采用非连续分配管理方式, 可以将作业要求的内存空间分散在内存的各个区域, 但需要额外的空间去存储分散区域的索引, 使得非连续分配方式的存储密度低于连续分配.

非连续分配管理方式根据分区的大小是否固定, 分为分页存储管理方式和分段存储管理方式.

在分页管理方式中, 又根据运行作业时是否需要把作业的所有页面都装入内存才能运行, 分为基本分页存储管理方式和请求分页存储管理方式.

1. 基本分页存储管理方式

固定分区会产生内部碎片, 动态分区会产生外部碎片.

分页思想: 把主存空间划分为大小相等且固定的块, 块相对较小, 作为主存的基本单位. 每个进程也以块为单位进行划分, 进程在执行时, 以块为单位逐个申请主存中的块空间.

分页管理不会产生外部碎片, 内部碎片也只有最一个不完整的块申请的主存空间中存在未用完的主存. 

a. 分页存储的几个基本概念

页面和页面的大小. 进程中的块称为页, 内存中的块称为页框, 或页帧. 外内也以同样的单位进行划分, 直接称为块. 进程在执行时需要申请主存空间, 即为每个页面分配主存中的可用页框, 这就首开了页和页框的一一对应. 页面大小应是2的整数幂, 且大小应该适中.

**如何确定页面大小:**

经验之谈: 过小, 页面数过多, 页表会过长, 占用大量内存, 而且也会增加硬件地址转换的开销, 降低页面换入/换出效率; 页面过大又会使页内碎片增多, 降低内存的利用率.

地址结构. 总共32位, 0 - 11 位为页内地址(页内偏移量)即页大小为4KB; 12 - 31位为页号, 地址空间共允许2 ** 20 页. 地址结构决定了虚拟内存的寻址空间有多大.

页表. 为了便于在内存中找到进程的每个页面所对应的物理块. 系统为每个进程建立一张页表, 它记录页面在内存中对应的物理块号. 页表一般存放在内存中. 在进程执行时, 通过查找该表, 即可找到每页在内存中的物理块号. 其作用为实现页号到物理块号的地址映射.

b. 基本地址变换机构

地址变换机构的任务是将逻辑地址转换为内存中的物理地址, 地址变换是借助于页表实现的(页表的作用是找到该页在内存中的位置).

地址结构 = 页号P + 页内偏移W

页表项 = 页号P + (物理内存中的)块号b

知道页面大小L, 页表项长度, 页表起始地址F, 页表项内容b, 页表项地址

物理地址E = b * L + W

**如何计算页表项大小:**

计算页面数, 页表项 = 页号 + 块号; 页号要足够大容量全部的页号

c. 具有快表的地址变换机构

若页表全部放在内存中, 则存取一个数据或一条指令至少要访问**2次**内存: 第一次访问页表, 根据逻辑地址找物理地址; 第二次根据物理地址取数据或指令.

显然上述方式比通常执行指令要慢一半. 为此, 在地址变换机构中增设一个具有并行查找能力的调整缓冲存储器 -- 快表, 又称相联存储器(TLB).

具有该机构的分布机制上, 查找过程如下:

1. CPU给出逻辑地址后, 由硬件进行地址转换, 将页号送入高速缓冲寄存器, 并将此页号与快表中的所有页号进行比较.
2. 找到, 则直接取出与页内偏移拼接形成物理地址.
3. 未找到, 访问页表, 读到后将其存入快表, 以便再次访问, 快表满, 则以一定的算法进行替换.

一般快表的命中率可达90%以上, 这样分页带来的速度损失就可降低到10%以下. 快表的有效性基于著名的局部性原理.

d. 两级页表

解决实际执行时进入内存的进程只有几十个进程页面的大小来说, 将整个进程的页表全放进内存降低了内存的利用率. 进一步延伸页表映射的思想, 得到二级分页. 在进程执行时, 将上一级页表调入内存即可, 进程的页表和进程本身的页面可在后面的执行中再调入内存.

建立多级面表的目的在于建立索引, 以便不用浪费主存空间去存储无用的页表项, 也不用盲目地顺序式查找面表项.

2. 基本分段存储管理方式

分页管理方式是从计算机的角度考虑设计的, 目的是提高内存的利用率, 提升计算机的性能; 分页通过硬件机制实现, 对用户完全透明. 分段管理方式的提出则考虑了用户和程序员, 以满足方便编程, 信息保护和共享, 动态增长及动态链接等多方面的需要.

a. 分段

段式管理方式按照用户进程中的自然段划分逻辑空间. 例如, 用户进程由主程序两个子程序, 栈和一段数据组成, 于是可以把这个用户进程划分为5段, 每段从0开始编址, 并分配一段连续的地址空间(段内连续, 段间不连续, 因此整个作业的地址空间是二维的), 其逻辑地址由段号S与段内偏移量W两部分组成.

在页式系统中, 逻辑地址的页号和页内偏移量对用户是透明的, 但在段式系统中, 段号和段内偏移量必须由用户显式提供, 在高级程序设计语言中, 这个工作由编译程序完成.

b. 段表

每个进程都有一张逻辑空间与内存空间的映射段表, 段表项内容如下:

段号 + 段长 + 本段在主存的始址

...

3, 段页管理方式

页式存储管理能有效地提高内存利用率, 页分段存储管理能反映程序的逻辑结构并有利于段的共享. 2者结合为段页存储管理方式.

作业的逻辑地址分为:  段号S + 页号P + 页内偏移量W

为了实现地址转换, 系统为每个进程建立一张段表, 每个分段有一张页表. 

段表表项中至少包括段号, 页表长度和页表起始地址; 页表表项至少包括页号和块号.

系统中还应有一个段表寄存器, 指出作业的段表始址和段表长度(段表寄存器和页表寄存器的作用都有两个: 一是在段表或页中寻址; 二是判断是否越界)

### 文件管理

**文件系统基础**

- 文件的概念

文件是以计算机硬盘为载体的存储在计算机上的信息集合, 文件可以是文本文档, 图片, 程序等.

文件的结构, 自下而上的**定义**如下: 

1. 数据项

数据项是文件系统中最低级的数据组织形式, 可分为两种类型: 基本数据项(描述对象的某种属性的一个值); 组合数据项

2. 记录

一组相关的数据项的集合, 用于描述一个对象在某方面的属性, 如一名考生的报名记录包括考生姓名, 出生日期, 报考学校的代号等.

3. 文件

文件是指由创建者所定义的一组相关信息的集合, 逻辑上可分为有结构文件和无结构文件两种. 在有结构文件中, 文件一组相似的记录组成, 如报考某学校的所有考生的报考信息记录, 又称记录式文件; 而无结构文件则被视为一个字符流, 比如一个二进制文件或字符文件, 又称为流式文件.

文件的**属性**: 名称, 标识符, 类型, 位置, 大小, 保护, 时间日期和用户标识

文件的**基本操作**: 创建文件, 写文件,读文件, 文件重定位, 删除文件, 截断文件

文件的**打开与关闭**: open返回一个指向打开文件表中的一个条目的指针, 通过该指针进行所有I/O操作, 以简化步骤并节省资源. (File Control Block, FCB 包含文件指针, 文件计数器等信息)

- 文件的逻辑结构

按逻辑结构, 文件可划分为无结构文件和有结构文件两种.

1. 无结构文件(流式文件)

无结构文件是最简单的文件组织形式. 无结构文件将数据按顺序组织成记录并积累, 保存, 它是有序相关信息项的集合, 以字节(Byte)为单位.

对大多数应用不适用, 但字节流的无结构文件管理简单, 用户可以方便地对其进行操作. 适用于对基本信息操作不多的文件, 如源程序文件, 目标代码文件.

2. 有结构文件(记录式文件)

a. 顺序文件

记录通常是定长的, 顺序存储或链表形式存储, 在访问时需要顺序搜索文件. 在每次要卖写一大批记录时, 顺序文件的效率是所有逻辑文件中最高的.

b. 索引文件

定长记录文件 & 变长记录文件2种; 变长记录文件只能顺序查找, 系统开销大. 为此, 建立一张索引表以加快检索速度.(索引表本身是定长记录的索引表).

c. 顺序索引文件

顺序文件与索引文件相结合: 分组索引, 再顺序查找

d. 直接文件或散列文件

给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址

- 目录结构

1. 文件控制块和索引结点

文件控制块(File Control Block, FCB): 用来存放控制文件需要的各种信息的数据结构, 以实现"按名存取". FCB的有序集合称为**文件目录**, 一个FCB就是一个文件目录项. FCB主要包含以下信息:

a. 基本信息, 如文件名, 文件的物理位置, 文件的逻辑结构, 文件的物理结构等

b. 存取信息, 如文件存取权限等

c. 使用信息, 如文件建立时间, 修改时间等

索引结点: 文件名与文件描述信息分开的方法, 文件描述信息单独形成一个称为索引结构的数据结构, 简称i结点. 在文件目录中的每个目录项仅由文件名和指向该文件所对应的i结点的指针构成.

存放在磁盘上的索引结点称为磁盘索引结点, UNIX中的每个文件都有一个唯一的磁盘索引结点, 主要包括以下几个方面:

a. 文件主标识符, 拥有该文件的个人或小组的标识符

b. 文件类型, 包括普通文件, 目录文件或特别文件

c. 文件存取权限, 各类用户对该文件的存取权限

d. 文件物理地址

e. 文件长度, 字节为单位

f. 文件链接计数, 本系统中所有指向该文件的文件名的指针计数

g. 文件存取时间, 本文件最近被进程存取的时间

文件被打开时, 磁盘索引结点复制到内存的索引结点中, 以便于使用. 在内存索引结点中又增加了以下内容:

h. 索引结点编号, 用于标识内存索引结点

i. 状态, 指示i结点是否上锁或被修改

j. 访问计数, 每当有一进程要访问此i结点时, 计数加1, 访问结束减1

k. 逻辑设备号, 文件所属文件系统的逻辑设备号

l. 链接指针, 设置分别指向空闲链表和散列队列的指针.

2. 目录结构

在目录这个层次上所需的操作:

a. 搜索

b. 创建文件

c. 删除文件

d. 显示目录

e. 修改目录

单级目录结构

两级目录结构

多级目录结构(树形目录结构)

无环图目录结构

- 文件共享

文件共享使多个用户共享一个文件, 系统中只需保留该文件的一个副本. 文件共享范围已由单机系统发展到多机系统, 进而通过网络扩展到全球(通过分布式文件系统, 远程文件系统, 分布式信息系统实现的). 

1. 基于索引结点的共享方式(硬链接)

索引结点, 链接计数, 新增时, 索引结点链接计数增加, 为0时系统负责删除

2. 利用符号链实现文件共享(软链接)

创建一个LINK类型的新文件, 写入文件目录, 但新文件中只包含被链接文件的路径名. 只有文件的拥有者才拥有指向其索引结点的指针, 而共享文件的其他用户只有该文件的路径名!

在网络共享中, 符号链接只需提供该文件所在机器的网络地址及该机器中的文件路径.

硬链接的查找速度比软链接的要快.(直接拥有指向索引结点的指针)

- 文件保护

文件保护通过: 口令保护, 加密保护和访问控制等方式实现. 

1. 访问类型

对文件的保护, 可以从限制对文件的访问类型着手, 文件的访问类型有: 

读, 写, 执行, 添加, 删除, 列表清单(列出文件名与文件属性). 此外, 还可以对文件的重命名, 复制, 编辑等加以控制. (保护可以只在低层提供, 如: 复制可利用一系列的读请/写求来完成)

2. 访问控制

解决访问控制最常用的方法是根据用户身份进行控制. 采用访问控制列表(Access-Control List, ACL), 以规定每个用户名及其允许的访问类型

精简的访问列表采用拥有者, 组, 其他三种用户类型.

其他的方法: 口令与密码, 口令是指用户在建立一个文件时提供一个口令, 系统为其建立FCB时附上相应口令, 同时告诉允许共享该文件的其他用户. 用户在请求访问时必须提供相应的口令(压缩文件的密码类似于...); 密码是指用户对文件进行加密, 文件被访问时需要使用密钥, 保密性强, 节省了存储空间, 但编码和译码都要花费一定的时间.

**文件系统实现**

- 文件系统层次结构

现代操作系统有多种文件系统类型(如 FAT32, NTFS, ext2, ext3, ext4等), 大体上分为:

1. 用户调用接口

文件系统为用户提供与文件及目录有关的调用, 如新建, 打开, 读写, 关闭, 删除文件, 建立/删除目录等.

2. 文件目录系统

主要功能是管理文件目录, 其任务有管理活跃文件目录表, 管理读写状态信息表, 管理用户进程的打开文件表, 管理与组织存储设备上的文件目录结构, 调用下一级存取控制模块.

3. 存取控制验证

实现文件保护主要由该级软件完成, 它把用户的访问要求与FCB中指示的访问控制权限进行比较, 以确认合法性.

4. 逻辑文件系统与文件信息缓冲区

主要功能是根据文件的逻辑结构将用户要读写的逻辑记录转换成文件逻辑结构内的相应块号.

5. 物理文件系统

主要功能是把逻辑记录所在的相对块号转换成实际的物理地址.

6. 辅助分配模块

分配模块主要功能是管理辅存空间, 即负责分配辅存空闲空间和回收辅存空间.

7. 设备管理程序模块

主要功能是分配设备, 分配设备读写用缓冲区, 磁盘调度, 启动设备, 处理设备中断, 释放设备读写缓冲区, 释放设备.

- 目录实现在
  
读文件前, 必须先打开文件. 打开文件时, 操作系统利用路径名找到相应的目录项, 目录项中提供了查找文件磁盘所需要的信息. 目录实现的基本方法有线性列表和哈希表两种(对应线性查找和散列查找)

1. 线性列表

2. 哈希表

- 文件实现

文件实际上是一种抽象数据类型, 研究其逻辑结构, 物理结构以及关于它的一系列操作. 文件的实现就是研究其物理结构, 即文件数据在物理存储设备年是如何分布和组织的. 同一个问题有2个方面的回答: 一是文件的分配方式, 讲的是对磁盘非空闲块的管理; 二是文件存储空间管理, 讲的是对磁盘空闲块的管理;

1. 文件分配方式

