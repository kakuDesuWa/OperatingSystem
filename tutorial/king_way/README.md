# 王道论坛 - 操作系统

- [计算机系统概述](#计算机系统概述)
- [进程管理](#进程管理)


### 计算机系统概述

**操作系统的基本概念**

- 操作系统的概念

计算机系统自下而上可大致分为4部分: 硬件, 操作系统, 应用程序和用户. 操作系统管理各种计算机硬件, 为应用程序提供基础, 并充当计算机硬件与用户之间的中介.

硬件如中央处理器, 内存, 输入/输出设备等, 提供基本的计算资源. 应用程序如字处理程序, 电子制表软件, 编译器, 网络浏览器等, 规定按何种方式使用这些资源来解决用户的计算问题. 操作系统控制和协调各用户的应用对硬件的分配与使用.

综上, 操作系统(Operating System, OS)是指控制和管理整个计算机系统的硬件与软件资源, 合理的组织, 高度计算机的工作与资源的分配, 进而为用户和其他软件提供方便接口与环境的程序集合.

- 操作系统的特征

操作系统的基本特征包括并发, 共享, 虚拟和异步. 

1. 并发(Concurrence)

并发是指两个或多个事件在同一时间间隔内发生. 操作系统的并发性是指计算机系统中同时存在多个运行的程序, 因此它具有处理和高度多个程序同时执行的能力. 在操作系统中, 引入进程的目的是使程序能并发执行.

注意同一时间间隔(并发)和同一时刻(并行)的区别. 在多道程序环境下, 一段时间内, 宏观上有多道程序在同时执行, 而在每个时刻, 单处理机环境下实际仅能有一道程序执行, 因此微观上这些程序仍是分时交替执行. 操作系统的并发性是通过分时得以实现的.

2. 共享(Sharing) 

资源共享, 是指系统中的资源可供内存中多个并发执行的进程共同使用. 共享可分为以下两种方式:

a. 互斥共享方式

系统中的资源如, 打印机, 磁带机, 虽然可供多个进程使用, 但一段时间内只允许一个进程访问资源(称为临界资源或独占资源)

b. 同时访问方式

系统中还有另一类资源, 允许在同一段时间内由多个进程"同时"访问. 这里所说的"同时"通常是宏观上的, 而在微观上, 这些进程可能是交替地对资源进行访问即"分离共享"的. 可供多个进程"同时"访问的典型资源是磁盘设备, 一些用重入码编写的文件也可被"同时"共享, 即允许若干个用户同时访问该文件.

并发与共享是操作系统两个最基本的特征, 两都之间互为存在的条件: 1. 资源共享是以程序的并发为条件的, 若系统不允许程序并发执行, 则自然不存在资源共享问题; 2. 若系统不能对资源共享实施有效的管理, 则必将影响到程序的并发执行, 甚至根本无法并发执行.

3. 虚拟(Virtual)

虚拟是指把一个物理上的实体变为若干逻辑上的对应物. 操作系统的虚拟技术可归纳为: 时分复用技术, 如处理器的分时共享; 空分复用技术, 如虚拟存储器;

4. 异步(Asynchronism)

多道程序环境允许多个程序并发执行, 但由于资源有限, 进程的执行并不是一贯到底的, 而是走走停停的, 它以不可预知的速度向前推进, 这就是进程的异步性.

异步性使得操作系统运行在一种随机的环境下, 可能导致进程产生与时间有关的错误(就像对全局变量的访问顺序不当会导致程序出错一样). 

- 操作系统的目标和功能

目标: 给多道程序提供良好的运行环境.

功能: 处理机管理(进程管理), 存储器管理, 设备管理, 文件管理. 为了方便用户使用操作系统, 还必须向用户提供接口作.

1. 处理机管理

可归结为对进程的管理, 并发是指在计算机同时运行多个进程, 因此进程何时创建, 何时撤销, 如何管理, 如何避免冲突, 合理共享就是进程管理的最主要的任务. 进程管理的主要功能包括进程控制, 进程同步, 进程通信, 死锁处理, 处理机高度等

2. 存储器管理

为给多道程序的运行提供良好的环境, 方便用户使用及提高内存的利用率. 主要包括内存分配, 地址映射, 内存保护与共享和内存扩充等功能.

3. 文件管理

操作系统中负责文件管理的部分称为文件系统. 文件管理包括文件存储空间的管理, 目录管理及文件读写管理和保护.

4. 设备管理

主要任务是完成用户的I/O请求, 方便用户使用各种设备, 并提高设备的利用率, 主要包括缓冲管理, 设备分配, 设备处理和虚拟设备等功能.

为方便用户使用计算机, 操作系统还提供了用户接口. 主要分2类:

1. 命令接口

又分联机命令接口, 交互式命令接口; 脱机命令接口, 批处理命令接口;

2. 程序接口

程序接口由一组系统调用命令组成. 如图形用户界面(GUI).

**操作系统的发展与分类**

- 手工操作阶段(此阶段无操作系统)

- 批处理阶段(操作系统开始出现)

为了解决手工操作阶段的人机矛盾及CPU和I/O设备之间速度不匹配的矛盾, 出现了批处理系统. 它按发展历程又分为单道批处理系统, 多道批处理系统(多道程序设计技术出现以后)

1. 单道批处理系统

a. 自动性

b. 顺序性

c. 单道性

2. 多道批处理系统

a. 多道

b. 宏观上并行

c. 微观上串行

- 分时操作系统

分时是指把处理器的运行时间分成很短的时间片, 按时间片轮流把处理器分配给各联机作业使用. 分时操作系统也是支持多道程序设计的系统. 主要特征如下:

1. 同时性
2. 交互性
3. 独立性
4. 及时性

- 实时操作系统

为了能在某个时间限制内完成某些紧急任务而不需要时间片排队, 诞生了实时操作系统. 分为硬实时操作系统与软实时系统, 分别应用场景有飞机的飞行自动控制系统; 飞机订票,银行管理系统.

- 网络操作系统和分布式计算机系统

网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信

分布式计算机系统是由多台计算机组成并满足下列条件的系统: 

1. 系统中任意两台计算机通过通信方式交换信息
2. 系统中的每台计算机都具有同等的地址, 即没有主机也没有从机
3. 每台计算机上的资源为所有用户共享
4. 系统中的任意台计算都可以构成一个子系统, 并且还能重构
5. 任何工作都可以分布在几台计算机上, 由它们并行工作, 协同完成.

主要特点: 分布性和并行性.

- 个人计算机操作系统

Window, Linux

- 嵌入式操作系统, 服务器操作系统, 多处理器操作系统

**操作系统的运行环境**

- 操作系统的运行机制

计算机系统中, 通常CPU执行2种不同性质的程序: 一种是操作系统内核程序; 另一种是用户自编程序(应用程序). 内核程序可以执行特殊指令. 在具体实现上, 将CPU的状态划划分为用户态和核心态(内核态). 应用程序运行在用户态, 内核程序运行在核心态.

层次式结构, 与硬件关联较紧密的模块, 如时钟管理, 中断处理, 设备驱动等处于最低层. 其次是运行频率较高的程序, 如进程管理, 存储器管理和设备管理. 这部分内容的指令操作工作在核心态.

大多数操作系统内核包括四方面的内容:

1. 时钟管理

最关键的设备

2. 中断机制

键盘或鼠标信息的输入, 进程的管理和高度, 系统功能的调用, 设备驱动, 文件访问等都依赖于中断机制. 现代操作系统是靠中断驱动的软件.

3. 原语

按层次设计的操作系统, 底层是一些可被调用的公用小程序. 它们各自完成一个规定的操作, 特点如下:

a. 处于操作系统的最低层, 是最接近硬件的部分

b. 这些程序的运行具有原子性, 其操作只能一气呵成(主要从系统安全性和便于管理考虑)

c. 这些程序的运行时间都比较短, 而且调用频繁

4. 系统控制的数据结构及处理

系统中用来登记状态信息的数据结构很多, 如作业控制块, 进程控制块(PCB), 设备控制块, 各类链表, 消息队列, 缓冲区, 空闲区登记表, 内存分配表等. 为了实现有效的管理, 系统需要一些基本的操作, 常见的操作有下三种:

a. 进程管理

进程状态管理, 进程调用和分派, 创建与撤销进程控制块等

b. 存储器管理

存储器的空间分配和回收, 内存信息保护程序, 代码对换程序等

c. 设备管理

缓冲区管理, 设备分配和回收等

- 中断和异常的概念

操作系统中引用了核心态和用户态这两种工作状态后, 就需要考虑如何切换. 操作系统工作在内核态, 用户程序工作在用户态. 系统不允许用户程序实现核心态的功能, 而它们又必须使用这些功能. 通过中断或异常实现之. 发生中断或异常时, 运行用户态的CPU会立即行内核态, 这是通过硬件实现的.

中断机制非常重要, 原因是, 操作系统的发展过程大体上就是一个想方设法不断提高资源利用率的过程, 而提高资源利用率就需要在程序并未使用某种资源时, 把它对那种资源的占有权释放, 而这一行为就需要通过中断实现.

中断(Interruption)也称外中断, 指来自CPU执行指令以外的事件的发生, 如设备发出的I/O结束中断, 时钟中断, 表示一个固定的时间片已到. 这一类中断通常是与当前程序运行无关的事件, 即它们与当前处理机运行的程序无关.

异常(Exception)也称内中断, 例外或陷入(trap), 指源自CPU执行指令内部的事件, 如程序的非法操作码, 地址越界, 算术溢出等引起的事件. 对异常的处理一般要依赖于当前程序的运行现场, 且异常不能被屏蔽, 一旦出现应立即处理.

- 系统调用

系统调用, 是指用户在程序中调用操作系统所提供的一些子功能, 系统调用可视为特殊的公共子程序. 系统中的各种共享资源都由操作系统统一掌管, 因此在用户程序中, 几是与资源有关的操作(如存储分配, 进行I/O传输及管理文件等), 都必须通过系统调用方式向操作系统提出服务请求, 并由操作系统代为完成. 系统调用按功能大致可分为如下几类:

1. 设备管理, 完成设备的请求或释放, 以及设备启动等功能.
2. 文件管理, 完成文件的读, 写, 创建及删除等功能.
3. 进程控制, 完成进程的创建, 撤销, 阻塞及唤醒等功能.
4. 进程通信, 完成进程间的消息传递或信号传递等功能.
5. 内存管理, 完成内存的分配, 回收以及获取作业占用内存区大小及始址等功能.

系统调用的处理需要由操作系统内核程序负责完成, 要运行在内核态. 用户程序执行"陷入指令", 相当于CPU的使用权主动交给操作系统内核程序(CPU状态由用户态进入内核态), 之后操作系统内核程序再对系统调用请求做出相应处. 

- 操作系统的体系结构

**大内核和微内核**

大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态, 从而为应用程序提供高性能的系统服务. 因为各管理模块之间共享信息, 能有效利用相互之间的有效特性, 所以具有无可比拟的性能优势. 规模增长, 程序复杂性增高. 

微内核结构, 将内核中最基本的功能(如进程管理等)保留在内核, 而将那些不需要在核心态执行的功能移到用户态执行, 从而降低了内核的设计复杂性.

微内核结构有效的地分离了内核与服务, 服务与服务, 使得它们之间的无病呻吟更加清晰, 维护的代价大大降低, 各部分可以独立地优化和演进, 从而保证了操作系统的可靠性. 但需要频繁地在核心态和用户态切换, 导致出现性能问题.

### 进程管理

**进程与线程**

- 进程的概念和特征

概念:

在多道程序环境下, 允许多个程序并发执行, 此时它们将推动封闭性, 并具有间断性及不可再现性的特征. 为此引入了进程的概念, 以便更好的描述和控制程序的并发执行. 实现操作系统的并发性与共享性(最基本要的2个特性).

Process Control Block, PCB是系统用来描述进程的基本情况和运行状态, 进而控制和管理进程的数据结构. 程序块, 相关数据块和PCB三部分构成了进程映像(进程实体). 所谓创建进程, 实质上是创建进程映像中的PCB; 同样, 撤销进程实质上是撤销进程的PCB.

PCB是进程存在的唯一标志.

进程有多种定义, 比较典型的如下:

1. 进程是程序的一次执行过程
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
3. 进程是具有独立功能的程序在一个数据集上运行的过程, 它是系统进行资源分配和高度的一个独立单位.

特征:

1. 动态性
2. 并发性
3. 独立性
4. 异步性
5. 结构性

- 进程的状态与转换

通常进程有以下五种状态, 前三种是进程的基本状态(运行, 就绪, 阻塞)

1. 运行态
2. 就绪态
3. 阻塞态
4. 创建态
5. 结束态

- 进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理, 它具有创建新进程, 锒铛已有进程, 实现进程状态转换等功能. 在操作系统中, 一般把进程控制用的程序段称为原语, 原语的特点是执行期间不允许中断, 它是一个不可分割的基本单位. 

1. 进程的创建

允许一个进程创建另一个进程, 些时创建者称为你进程, 被创建的进程称为子进程. 子进程可以继承父进程所拥有的资源. 当子进程被撤销时, 应将其从父进程那里获得的资源归还给父进程. 此处, 在撤销父进程时, 必须同时撤销其所有的子进程.

在操作系统中, 终端用户登录系统, 作业高度, 系统提供服务, 用户程序的应用请求等都会引起进程的创建. 操作系统创建一个新进程的过程如下:

a. 为新进程分配一个唯一的进程标识号, 并申请一个空白的PCB(PCB是有限的). 若PCB申请失败, 则创建失败.

b. 为进程分配资源, 为新进程的程序和数据及用户栈分配必要的内存空间(在PCB中体现). 注意, 若资源不足(如内存空间), 则并不是创建失败, 而是处于"等待态"或称"阻塞态", 等待的是内存这个资源. 

c. 初始化PCB, 主要包括初始化标志信息, 初始化处理机状态信息和初始化处理机控制信息, 以及设置进程的优先级等.

d. 若进程就绪队列能够接纳新进程, 则将新进程插入就绪队列, 等待被高度运行.

2. 进程的终止

引起进程终止的事件主要有: 

a. 正常结束, 表示进程的任务已经完成并准备退出运行. 

b. 异常结束, 表示进程在运行时, 发生了某种异常事件, 使程序无法继续运行, 如存储区越界, 保护错, 非法指令, 特权指令, I/O故障等. 

c. 外界干预, 是指进程应外界的请求而终止运行, 如操作员或操作系统干预, 父进程的请求和父进程终止.

3. 进程的阻塞和唤醒

正在执行的进程, 由于期待的某些事件未发生, 如请求系统资源失败, 等待某种操作的完成, 新数据尚未到达或无新工作可做等, 由系统自动执行阻塞原语(Block), 使自己由运行态变为阻塞态. 可见, 进程的阻塞是进程自身的一种主动行为, 也因此只有处于运行态的进程(获得CPU), 才可能将其转变为阻塞态.

当被阻塞的进程所期待的事件出现时, 如它所启动的I/O操作已完成或其所期待的数据已经到达, 由有关进程(如提供数据的进程)调用唤醒原语(Wakeup), 将等待该事件的进程唤醒.

4. 进程切换

对于通常的进程而言, 其创建, 撤销及要求由系统设备完成的I/O操作, 都是利用系统调用而进入内核, 再由内核中的相应处理程序予以完成的, 进程切换同样是在内核的支持下实现的. 

可以说任何进程都是在操作系统内核的支持下运行的.

进程切换是指处理机从一个进程的运行转到另一个进程上运行, 在这个过程中, 进程的运行环境产生了实质性的变化. 

- 进程的组织

1. PCB, 进程控制块

PCB组织方式: 链接式, 索引式

2. 程序段

程序段是指能被进程调度程序调度到CPU执行的程序代码块, 程序段可被多个进程共享.

3. 数据段

可以是进程对应的程序加工处理的原始数据, 也可以是程序执行时产生的中间结果或最终结果

- 进程的通信

进程通信是指进程之间的信息交换. PV操作是低级通信方式, 高级通信方式是指以较高的效率传输大量数据的通信方式. 高级通信方法主要有以下三类.

1. 共享存储

在通信的进程之间存在一块可直接访问的共享空间, 通过对这片共享空间进行写/读操作实现进程之间的信息交换, 需要使用同步互斥工具(如P操作, V操作)

2. 消息传递

在消息传递系统中, 进程间的数据交换是以格式化的消息(Message)为单位的. 若通论的进程之间不存在可直接访问的共享空间, 则必须利用操作系统提供的消息传递方法实现进程通信. 操作系统提供发送消息和接收消息2个原语进行数据交换.

又分为直接通信方式与间接通信方式.

3. 管道通信

所谓管道, 是指用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件, 又名pipe文件. 向管道(共享文件)提供输入的发送进程, 以字符流形式将大量的数据送入(写)管道; 而接收管道输出的接收进程(即读进程)则从管道中接收(读)数据. 为了协调双方的通信, 管道机制必须提供以下三方面的协调能力: 互斥, 同步和确定对方的存在.

管道为半双工通信, 实质是一个固定大小的缓冲区, read(), write() 在缓冲区空或满时被阻塞.

- 线程的概念和多线程模型

引入进程的目的是为了更好的使多道程序并发执行, 提高资源利用率和系统吞吐量, 增加并发程度; 而引入线程的目的则是为了减小程序在并发执行时所付出的时空开销, 提高操作系统的并发性能.

1. 线程的基本概念

线程最直接的理解就是"轻量级的进程", 它是一个基本的CPU执行单元, 也是程序执行流的最小单元, 由线程ID, 程序计数器, 寄存器集合的堆栈组成. 纯种是进程中的一个实体, 是被系统产独立调度和分派的基本单位, 线程自己不拥有系统资源, 只拥有一点在运行中必不可少的资源, 但它可与同属一个进程的其他线程共享进程所拥有的全部资源. 一个线程可以创建和撤销另一个线程, 同一个进程中的多个线程之间可以并发执行. 由于线程之间的相互制约, 致使线程在运行中呈现出间断性. 结线程也有就绪, 阻塞, 运行三种基本状态.

进程只作为除CPU外的系统资源的分配单元, 线程则作为处理机的分配单元. 由于一个进程内部有多个线程, 若线程的切换发生在同一个进程内部, 则只需很少的时空开销.

2. 线程与进程的比较

a. 调度, 在传统的操作系统中, 拥有资源和独立调度的基本单位都是进程. 在引入线程的操作系统中, 线程是独立调度的基本单位, 进程是拥有资源的基本单位. 在同一进程中, 线程的切换不会引起进程切换. 在不同的进程中进行统一线程切换, 会引起进程切换.

b. 拥有资源, 不论是传统操作系统还是设有线程的操作系统, 进程都是拥有资源的基本单位, 而线程不拥有系统资源(也有一点必不可少的资源), 但线程可以访问其隶属进程的系统资源. 

c. 并发性, 在引入线程的操作系统中, 不仅进程之间可以并发执行, 而且多个线程之间也可以并发执行, 从而使操作系统具有更好的并发性, 提高了系统的吞吐量.

d. 系统开销, 由于创建或撤销进程时, 系统都要为之分配或回收资源, 如内存空间, I/O设备等. 

e. 地址空间和其他资源(如打开的文件). 进程的地址空间之间互相独立, 同一个进程的各线程间共享进程的资源, 某进程内的线程对于其他进程不可见.

f. 通信方面. 进程间通信(IPC)需要进程同步和互斥手段的辅助, 以保证数据一一致性

3. 线程的属性

多线程操作系统把线程作为独立运行(或调度)的基本单位, 此时的进程已经不再是一个基本的可执行实体, 但它仍具有与执行相关的状态. 所谓进程处于"执行"状态, 实际上是指该进程中的某线程正在执行. 线程的主要属性有:

a. 线程是轻型实体, 它不拥有系统资源, 但每个线程都就有一个唯一的标识符和一个线程控制块, 纯种王控制块记录了线程执行的寄存器和栈等现场状态.

b. 不同的线程可以执行相同的程序, 即同一个服务程序被不同的用户调用时, 操作系统把它们创建成不同的线程.

c. 同一个进程中的各个线程共享该进程所拥有的资源.

d. 线程是处理机的独立调度单位, 多个纯种是可以并发执行的. 在单CPU的计算机中, 各纯种可交替地占用CPU; 在多CPU的计算机系统中, 各线程可同时占用不同的CPU. 若各个CPU同时为一个进程内的各线程服务, 则可缩短进程的处理时间.

e. 一个线程被创建后, 便开始了它的生命周期, 直至终止.

4. 线程的实现方式

线程的实现可以分为两类: 用户级线程(User-Level Thread, ULT)和内核级线程(Kernel-Level Thread, KLT)

在用户级线程中, 有关纯种管理的所有工作都由应用程序完成, 内核意识不到线程的存在. 应用程序可以通过使用线程库设计成多线程程序. 通常, 应用程序从单线程开始, 在该线程中开始运行, 在其运行的任何时刻, 可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程.

在内核级线程中, 线程管理的所有工作由内核完成, 应用程序没有进程纯种管理的代码, 只有一个到内核级线程的编程接口. 内核为进程及其内部的每个线程维护上下文信息, 调度也在内核基于线程架构的基础上完成. 

也有些混合方式的多线程实现.

5. 多线程模型

有些系统同时支持用户线程和内核线程, 由此产生了不同的多线程模型, 即实现用户线线程和内核级线程的连接方式.

a. 多对一模型, 将多个用户级线程映射到一个内核级线程, 线程管理在用户空间完成, 此模式上, 用户级线程对操作系统不可见.

优点: 线程管理是在用户空间进行的, 因而效率比较高.

缺点: 一个线程在使用内核服务时被阻塞, 整个进程都被阻塞; 多个线程不能并行地在多处理机上.

b. 一对一模型, 将每个用户级线程映射到一个内核级线程. 

优点: 当一个线程被阻塞后, 允许另一个线程继续执行, 所以并发能力较强.

缺点: 每创建一个用户级线程都需要创建一个内核级线程与其对应, 这样创建线程的开销比较大, 会影响到应用程序的性能.

c. 多对多模型

集上两者之所长.

**处理机调度**

- 调度的概念

1. 调度的基本概念

在多道程序系统中, 进程的数量往往多于处理机的个数, 因此进程急用处理机的情况在所难免. 处理机高度是对处理机进行分配, 即从就绪队列中按照一定的算法(公平, 高效)选择一个进程, 并将处理机分配给它运行, 以实现进程并发地执行. 

处理机调度是多道程序操作系统的基础, 是操作系统设计的核心问题.

2. 调度的层次

a. 作业调度, 又称高级调度, 其主要任务是按一定的原则从外在上处于后备状态的作业中挑选一个(或多个)作业, 给它(们)分配内在, 输入/输出设备等必要的资源, 并建立相应的进程, 以使它(们)获得竞争处理机的权利.

b. 中级调度, 又称内存调度, 其作用是提高内存利用率和系统吞吐量. 为些, 应将那些暂时不能运行的进程调至外存等待, 把此时的进程状态称为挂想态. 当它们已具备运行条件且内存又稍有空闲时, 由嘴调度来决定把外存上的那些具备运行条件的就绪进程, 再重新调入内存, 并修改其状态为就绪态, 挂在就绪队列上等待.

c. 进程调度, 又称低级调度, 其主要任务是按照某种方法和 策略从就绪队列中选取一个进程, 将处理机分配给它. 进程调度是操作系统中最基本的一种调度, 在一般的操作系统中都必须配置进程调度. 进程调度频率很高, 一般几十毫秒一次.

3. 三级调度的联系

作业调度从外存的后备的后备队列中选择一批作业进入内存, 为它们建立进程, 这些进程被卷入就绪队列, 进程调度从就绪队列中选出一个进程, 并把其状态改为运行态, 把CPU分配给它. 中级调度是为了提高内存的利用率, 系统将那些暂时不能运行的进程挂起来. 当内存空间宽松时, 通过中级调度选择具备运行条件的进程, 将其唤醒.

- 调度的时机, 切换与过程

进程调度和切换程序是操作系统内核程序. 

不能进行进程的高度与切换的情况有以下几种:

1. 在处理中断的过程中

2. 进程在操作系统内核程序临界区中

3. 其他需要完全屏蔽中断的原子操作过程中

- 进程调度方式

所谓进程调度方式, 是指当某个进程正在处理机上执行时, 若有某个更为重要或紧迫的进程需要处理, 即有优先权更高的进程进入就绪队列

分非剥夺调度与剥夺调度

- 调度的基本准则

评价不同处理机调度算法的性能, 有下几个维度:

1. CPU利用率
2. 系统吞吐量, 不同作业耗时不同
3. 周转时间, 是指从作业提交到作业完成所经历的时间, 是作业等待, 在就绪队列中排队, 在处理机上运行及进行输入/输出操作所花费时间的总和.
4. 等待时间, 指进程处于等处理机状态的时间之和, 衡量一个算法的好坏的生般考查量.
5. 响应时间, 响应时间指从用户提交请求到系统首次产生响应所用的时间. 在交互系统中, 一般采用响应时间作为衡量调度算法的重要准则之一.

- 典型的调度算法

1. 先来先服务(FCFS)调度算法

FCFS调度算法是一种最简单的调度算法, 它既可用于作业调度, 又可用于进程调度. 

在作业调度中, 算法每次从后备作业队列中选择最先进入该队列的一个或几个作业, 将它们调入内存, 分配必要的资源, 创建进程并放入就绪队列.

在进程调度中, FCFS调度算法每次从就绪队列中选择最先进入该队列的进程, 将处理机分配给它, 使之投入运行, 直到完成或因某种原因而阻塞时才释放处理机.

FCFS算法属于不可剥夺算法, 不能作为分时系统和实时系统的主要调度算法, 但常被结合其他调度调度策略中使用.

FCFS特点: 简单, 但效率低; 对长作业比较有利, 但对短作业不利(相对SJF和高响应比算法); 有利于CPU繁忙型作业, 不利于I/O繁忙型作业.

2. 短作业优先(SJF)调度算法

短作业(进程)优先调度算法是指对短作业(进程)优先调度的算法. 短作业优先(SJF)调度算法从后备队列中选择一个或若干估计运行时间最短的作业, 将它调入内存运行; 短进程优先调度算法(SPF)类似.

SJF调度算法也存在不容忽视的缺点:

a. 对长作业不利

b. 该算法完全未考虑作业的紧迫程度

c. 由于作业的长短只是根据用户所提供的估计执行时间而定, 并不能真正做到短作业优先

SJF是平均等待时间, 平均周转时间最少

3. 优先级调度算法

根据新的更高优先级进程能否抢占正在执行的进程, 该算法又可分为2种:

a. 非剥夺式优先级调度算法

b. 剥夺式优先级调度算法

而根据进程创建后其优先级是否可以改变, 可将进程优先级分为2种:

a. 静态优先级

b. 动态优先级

一般, 进程优先级的设置可以参照以下原则:

a. 系统进程 > 用户进程

b. 交互型进程 > 非交互型进程

c. I/O进程 > 计算型进程

4. 高响应比优先调度算法

高响应比优先调度算法主要用于作业高度, 是对FCFS调度算法和SJF调度算法的一种综合平衡, 同时考虑了每个作业的等待时间和估计的运行时间. 在每次进行作业调度时, 先计算后备作业队列中每个作业和响应比, 从中选出响应比最高的作业调入运行.

响应比 = (等待时间 + 要求服务时间) / 要求服务时间

5. 时间片轮转调度算法

时间片轮转调度算法主要适用于分时系统. 在该算法中, 系统将所有就绪进程按到达时间的先后次序排成一个队列, 进程调度程序总是选择就绪队列中的第一个进程执行, 即先来先有务的原则, 但仅能运行一个时间片, 如100ms. 时间片的大小对系统性能影响很大, 若时间片很大, 退化为FCFS算法. 若很小, 处理机频繁切换进程开销增大.

时间片大小的影响因素: 系统的响应时间, 就绪队列中的进程数目和系统的处理能力.

6. 多级反馈队列调度算法(融合了前几种算法的优点)

多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展. 

设置多个就绪队列, 每个队列赋予不同的优先级;

不同优先级队列的时间片不同;

新进程先进入第1级队列的末尾, 按FCFS原则排队等待调度, 若未完成, 放入第2级队列;

仅当第1级队列为空, 调度程序才调度第2级队列中的进程, 若处理机正在执行第i级队列中的某进程, 此时又有新进程进入优先级高的队列, 则此时新进程将抢占正在进行进程的处理;

**进程同步**

- 进程同步的基本概念

在多道程序环境下, 进程是并发执行的, 不同进程之间存在着不同的相互制约关系. 进程同步即为协调进程之间的相互制约关系.

1. 临界资源

一次仅允许一个进程使用的资源, 如打印机, 一些变量, 数据. 对临界资源的访问, 必须互斥的进行, 在每个进程中, 访问临界资源的那段代码可称为临界区. 临界资源访问的4部分:

a. 进入区, 进入临界区, 进入区要检查可否进入, 设置正在访问临界共的标志, 以阻止其他进程同时进入临界区

b. 临界区, 进程中访问临界资源的那段代码

c. 退出区, 将正在访问临界区的标志清除

d. 剩余区, 代码中的其余部分.

2. 同步

同步亦称直接制约关系, 进程间的直接制约关系源于它们之间的相互合作.

如输入进程A通过单缓冲向进程B提供数据, 当该缓冲区空时, 进程B不能获得所需数据而阻塞, 一旦进程A将数据送入缓冲区, 进程B就被唤醒. 反之, 当缓冲区满时, 进程A被阻塞, 仅当进程B取走缓冲数据时, 才唤醒进程A.

3. 互斥

互斥也称间接制约关系, 如打印机资源, A进程使用打印机, 必须等B进程释放打印机资源.

- 实现临界区互斥的基本方法

1. 软件实现方法

在进入区设置并检查一些标志来标明是否有进程在临界区中, 若已有进程在临界区, 则在进入区通过循环检查进行等待, 进程离开临界区后则在退出区修改标志.

算法1: 单标志法(违背空闲让进), 设置turn

算法2: 双标志法先检查(违背忙则等待), 设置flag

算法3: 双标志法后检查(饥饿现象), 设置flag

算法4: Peterson's Algorithm. 设置turn与flag

2. 硬件实现方法

a. 中断屏蔽方法

当一个进程正在使用处理机执行它的临界区代码时, 防止其他进程进入临界区进行访问的最简方法是, 禁止一切中断发生, 称之为屏蔽中断, 关中断.(CPU只在发生中断时切换进程)

这种方法限制了处理机交替执行程序的能力, 因此执行效率会明显降低. 

b. 硬件指令方法

TestAndSet指令: 这条指令是原子操作, 即执行代码时不允许被中断. 其功能是读出指定标志后把该标志设置为真. 

Swap指令: 该指令的功能是交换两个字(字节)的内容.

- 信号量

信号量机制是一种功能较强的机制, 可用来解决互斥与同步问题, 它只能被两个标准的原语wait(S)和signal(S)访问, 也可记为"P"操作和"V"操作.

原语是指完成某种功能且不被分割, 不被中断执行的操作序列, 通常可由硬件来实现. 例如前面的TestAndSet, Swap. (原语功能在单处理机上可由软件通过屏蔽中断实现)

1. 整型信号量

整形信号量被定义为一个用于表示资源数目的整形量S, wait和signal操作可描述为

```
wait(S) {
    while(S<=0);
    S = S - 1;
}

signal(S) {
    S = S + 1;
}
```

wait操作中, 只要信号量S<=0就会不断测试. 该机制并未遵循"让权等待", 而是使进程处于"忙等"的状态.

2. 记录型信号量

记录型信号量是不存在"忙等"现象的进程同步机制. 除需要一个用于代表资源数目的整形变量value外, 再增加一个进程链表L, 用于链接所有等待该资源的进程. 记录型信号量得名于采用记录型的数据结构. 记录型信号量可描述为:

```
typedef struct{
    int value;
    struct process *L;
} semaphore
```

相应的wait(S)和signal(S)操作如下:

```
void wait(semaphore S) {
    S.value--;
    if(S.value) {
        // add this process to S.L;
        block(S.L);
    }
}
```

wait操作, S.value-- 表示进程请求一个该类资源, 当S.value<0时, 表示该资源已分配完毕, 因此进程应调用block原语, 进行自我阻塞, 放弃处理机, 并插入该类资源的等待队列S.L, 可见该机制遵循了"让权等待"的准则.

```
// 相当于释放资源
void signal(semaphonre S) {
    S.value++;
    if(S.value<=0) {
        // remove a process from S.L
        wakeup(P);
    }
}
```

signal操作, 表示进程释放一个资源, 使系统中可供分配的该类资源数增1, 帮有S.value++.若加1后仍是S.value<=0, 则表示在S.L中仍有等待该资源的进程被阻塞, 故还应调用wakeup原语, 将S.L中的第一个等待进程唤醒.

3. 利用信号量实现同步

信号量机制能用于解决进程间的各种同步问题. 设S为实现进程P1, P2同步的公共信号量, 初值为0. 进程P2中的语句y要使用进程P1中语句x的运行结果, 所以只有当语句x执行完成之后语句y才可以执行. 其实现进程同步的算法如下示意:

```
semaphore S=0;

P1(){
    ...     // do some thing
    x;      // 语句x    
    V(S);   // 告诉进程P2, 语句x已经完成
    ...     // do some thing
}

P2(){
    ...     // do some thing
    P(S);   // 检查语句x是否已经运行完成
    y;      //检查无误, 运行y语句
    ...     // do some thing
}
```

4. 利用信号量实现进程互斥

信号量机制也能很方便解决进程互斥问题, 设S为实现进程P1, P2互斥的信号量,由于每次只允许一个进程进入临界区, 所以S的初值应为1(即可用资源数为1). 只需把临界区置于P(S)和V(S)之间, 即可实现两个进程对临界资源的互斥访问, 其算法如下示意:

```
semaphore S=1;

P1(){
    ...
    P(S);           // 准备开始访问临界资源, 加锁
    进程P1的临界区;
    V(S);           // 访问结束, 解锁
    ...
}

P2(){
    ...
    P(S);           // 准备开始访问临界资源, 加锁
    进程P2的临界区;
    V(S);           // 访问结束, 解锁
    ...
}
```

互斥是不同进程对同一信号量进行P, V操作实现的, 一个进程成功对信号量执行了P操作后进入临界区, 并在退出临界区后, 由该进程对该信号量执行V操作, 表示当前没有进程进入临界区, 可以让其它进程进入.

5. 利用信号量实现前驱关系

6. 分析进程同步和互斥问题的方法步骤

a. 关系分析

b. 整理思路

c. 设置信号量

- 管程

1. 管程的定义

系统中各种硬件资源和软件资源, 均可用数据结构抽象的描述其资源我, 即用少量信息和对资源所执行的操作来表征该淘汰, 而忽略它们的内部结构和实现细节. 

管程是由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块, 这组操作能初始化并改变管程中的数据和同步进程.

2. 管程的组成

a. 局部于管程的共享结构数据说明

b. 对该数据结构的进行操作的一组过程

c. 对局部于管程的共享数据设置初始值语句

3. 管程的基本特性

a. 局部于管程的数据只能被局部于管程内的过程所访问

b. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据

c. 每次仅允许一个进程在管程内执行某个内部过程

- 经典同步问题

1. 生产者 - 消费者问题

问题描述:

一组生产者进程和一组消费者进程共享一个初始为空, 大小为n的缓冲区, 只有缓冲区没满时, 生产者才能把消息放入缓冲区, 否则必须等待; 只有缓冲区不为空时, 消费者才能从中取出消息, 否则必须等待. 由于缓冲区是临界资源, 它只允许一个生产者放入消息, 或一个消费者从中取出消息.

```
semaphore   mutex = 1;
semaphore   empty = 1;
semaphore   full  = 1;

producer() {
    while(1) {
        produce an item in nextp;
        P(empty);                   // 需要什么P一下...请求资源
        P(mutex);                   // 用来控制互斥访问临界区
        add nextp to buffer;        // buffer为临界区, 互斥访问
        V(mutex);                   // 用来控制互斥访问临界区
        V(full);                    // 提供什么V一下...释放资源
    }
}

consumer() {
    while(1) {
        P(full);
        P(mutex);
        remove an item from buffer;
        V(mutex);
        V(empty);
    }
}
```

拓展问题:

桌子上有一个盘子, 每次只能向其中放入一个水果. 爸爸专向盘子中放苹果, 妈妈专向盘子中放橘子, 儿子专等吃盘子中的橘子, 女儿专等吃盘子中的苹果. 只有盘子为空时, 爸爸或妈妈才可向盘子中放一个水果; 仅当盘子中有自己需要的水果时, 儿子或女儿可以从盘子中取出.

```
semaphore plate = 1, apple = 0, orange = 0;

dad() {
    prepare an apple;
    P(plate);
    put the apple on the plate;
    V(plate);
}

mom() {
    prepare an orange;
    P(plate);
    put the orange on the plate;
    V(plate);
}

son() {
    while(1) {
        P(orange);
        take an orange from the plate;
        V(plate);
        eat the orange;
    }
}

daughter() {
    while(1) {
        P(apple);
        take an apple from the plate;
        V(plate);
        eat the apple;
    }
}
```

2. 读者-写者问题

问题描述:

有读者和写者两组并发进程, 共享一个文件, 当两个或以上的读进程同时访问共享数据时不会产生副作用, 但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误. 因此要求: 1. 允许多个读者可以同时对文件执行操作; 2. 只允许一个写者往文件中写信息; 3. 任一写者在完成写操作前不允许其他读者或写者工作; 4. 写者执行写操作前, 应让已有的读者和写者全部退出.

```
// 读进程优先

int count = 0;           // 用于记录当前的读者数量
semaphore mutex = 1;     // 用于保护更新count变量时的互斥
semaphore rw = 1;        // 用于保证读者和写者互斥地访问文件

writer() {
    while(1) {
        P(rw);          // 互斥访问共享文件
        writing;        // 写入
        V(rw);          // 释放共享文件
    }
}

reader() {
    while(1) {
        P(mutex);       // 互斥访问count变量
        if(count==0)    // 当第一个读进程读共享文件时, 阻止写进程写
            P(rw);
        count++;
        V(mutext)       // 释放互斥变量count
        reading;        // 读取
        P(mutex);       // 互斥访问count变量
        count--;
        if(count==0)    // 当最后一个读进程读完共享文件, 允许写进程写
            V(rw);
        V(mutex);
    }
}
```

```
// "写进程优先" or 读写公平

int count=0;
semaphore mutex=1;
semaphore rw=1;
semaphore w=1;

writer() {
    while(1) {
        P(w);
        P(rw);
        writing;
        V(rw);
        V(w);
    }
}

reader() {
    while(1) {
        P(w);
        P(mutex);
        if(count==0)
            P(rw);
        count++;
        V(mutex);
        V(w);
        reading;
        P(mutex)
        count--;
        if(count==0)
            V(rw)
        V(mutex);
    }
}
```

第二种方法的重点在于竞争`semaphore w`

3. 哲学家进餐问题

问题描述:

 一张圆桌边上坐着5名哲学家, 每两名哲学家之间的桌上摆一根筷子, 两根筷子中间是一碗米饭. 哲学家们倾注比重精力用于思考和进餐, 哲学家在思考时, 并不影响他人. 只有当哲学家饥饿时, 才试图拿起左, 右两根筷子(一根一根的拿起). 若筷子已经在他人手上, 则需要等待. 饥饿的哲学家只有同时拿到了两根筷子才可以进餐, 进餐完毕后, 放下筷子继续思考.

```
// 当一名哲学家左右两边筷子都可用时, 才允许他抓起筷子

semaphore chopstick[5]={1, 1, 1, 1, 1};     // 初始化信号量
semaphore mutex=1;                          // 设置取筷子的信号量

Pi() {
    do{
        P(mutex);               // 在取筷子前获得互斥量
        P(chostick[i]);         // 取左筷子
        P(chostick[(i+1)%5])    // 取右筷子
        V(mutex);               // 释放取筷子的信号量
        eat;
        V(chostick[i]);         // 放回左筷子
        V(chostick[(i+1)%5])    // 放回右筷子
        think;
    } while(1);
}
```

还可采用AND型信号量机制来解决哲学家进餐问题.

4. 吸烟者问题

假设一个系统有三个抽烟者进程和一个供应者进程. 每个抽烟者不停的卷烟并抽掉它, 但要卷起并抽掉一支烟, 抽烟者需要有三种材料 : 烟草, 纸和胶水. 三个抽烟者中, 第一个拥有烟草, 第二个拥有纸, 第三个拥有胶水. 供应者进程无限地提供三种材料, 供应者每次将2种材料放到桌子上, 拥有剩下一种材料的抽烟者卷一根烟并抽掉它, 并给供应者一个信号告诉已完成, 此时供应者就会将另外两种材料放到桌子上, 如此重复(让三个抽烟者轮流抽烟)

**死锁**

- 死锁的概念

1. 死锁的定义

在多道程序系统中, 由于多个进程的并发执行,改善了系统资源的利用率并提高了系统的处理能力, 但多个进程的并发执行也带来了死锁问题. 死锁是指多个进程因竞争资源而造成的一种僵局(互相等待), 若无外力作用, 这些进程都将无法向前推进.

2. 死锁产生的原因

a. 系统资源的竞争, 通常系统中拥有的不可剥夺资源, 其数量不足以满足多个进程运行的需要, 使得进程在运行过程中, 会因争夺资源而陷入僵局. 只有对不可剥夺的资源的竞争才可能产生死锁, 对可剥夺的资源的竞争是不会引起死锁的.

b. 进程推进顺序非法, 进程在运行过程中, 请求和释放资源的顺序不当, 也同样会导致死锁. 例如, 并发进程P1, P2分别保持了资源R1, R2, 而进程P1申请资源R2, 进程P2申请资源R1时, 两者都会因为所需资源被占用而阻塞. 信号量使用不当也会造成死锁. (等待对方的资源导致死锁)

c. 